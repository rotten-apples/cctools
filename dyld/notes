TODO for MacOS X:
- Figure out why setting the FULLYBOUND_STATE does not seem to work.  Doing the
  first two seem to break the work space putting disks on the desktop on the
  Cheetah4K78 twolevel partion on rino.apple.com
    - Changed try_to_use_prebound_libraries() in images.c to set the
      FULLYBOUND_STATE using SET_FULLYBOUND_STATE() on the execututable after
      the link state is set to FULLY_LINKED.
    - Changed set_prebound_state() in images.c to set the FULLYBOUND_STATE using
      SET_FULLYBOUND_STATE() on the library modules after the link state is
      set to FULLY_LINKED.
    Also why not set the executable's state to FULLYBOUND_STATE in
    set_images_to_prebound() in images.c?
- Change the symbol_list struct to be smaller and make the fields,
  remove_on_error, bind_fully and flat_reference all fit in 32 bits.
- Add the vm_region tags as per Robert Bowdidge email of 11/6/2000.
- Determine which existing API's should call link_library_module() with the
  new bind_fully parameter set to TRUE or link_object_module() with the new
  bind_fully parameter set to TRUE.
- Figure out a way to make the __TEXT segment of dyld read-only when the kernel
  bug to map it read only is fixed.  For ppc the problem is the instructions
  after __dyld_start in dyld_start.s which loads the value of the lable L1.
  These create relocation entries in a read only section but are not need to
  be relocated.  Until the kernel bug is fixed that honors the protection 
  a vm_protect() call on dyld's __TEXT segment could be done.
- Deal with mig not having a dyld_event_MsgError() call back for mig errors
  when user_dyld_event_server_callback() is called.
- Figure out if dyld should use malloc_error() to get "dyld: " in front of
  malloc error messages.

TODO:
- For hppa cache flushing use FDC and FIC on the written instruction address.

Changes for the 5.10 release (the cctools-433 release):
- Changed setup_prebound_coalesed_symbols() in symbols.c to skip looking for
  global coalesed symbols if flat_reference is FALSE.  Then a count of global
  coalesed symbols is kept for any other libraries.  Then if the count is zero
  the routine now returns before setting any symbol pointers.  Radar bug
  #2951657.

Changes for the 5.10 release (the cctools-423 release):
- Changed the default error handling to cause a break point trap.  This is done
  by calling the assembly routine halt() in the new file halt.s. For PowerPC and
  i386 it causes a break point trap. For the other architectures it does nothing
  and then exit() is called as usual.  Radar bug #2405619.
- Fixed a second bug in map_image() in images.c that if a non-split image had
  an empty segment it would think that mach_header was in that segment.  The
  change was to the logic that set mach_header_segment_vmaddr from the picked
  up segment's vmaddr.  Radar bug #2931784.

Changes for the 5.10 release (the cctools-422 release):
- Fixed a small memory leak when a malformed library is loaded via a search
  path.  The change was in load_library_image() in images.c just after the
  call to map_library_image().  A test of the return value of
  map_library_image() was added and if it fail the code it now jumps to the
  new load_library_image_cleanup3 lable for clean up.  Radar bug #2914747.

Changes for the 5.10 release (the cctools-421 release):
- Picked up the changes for notify_prebinding_agent() in images.c to use the
  mach server interface to fix_prebinding.  The new mig defs file 
  dyld_prebind.defs and the header file dyld_prebind_defs.h were also added.
  Also the Makefile was changed.  Radar bug #2944779.
- Added code in images.c to map_image() and notify_prebinding_agent() to use
  the SYSTEM_REGION_BACKED flag as returned by load_shared_file().  If the
  program is not using the system shared regions then fix_prebinding is not
  done.  Radar bug #2942209.
- Turned off fix_prebinding when the executable has MH_NOFIXPREBINDING set in
  the mach header.  Radar bug #2941669.
- Turned off fix_prebinding when the DYLD_NEW_LOCAL_SHARED_REGIONS environment
  variable is set.  Radar bug #2941669.

Changes for the 5.10 release (the cctools-419 release):
- Fixed a bug in map_image() in images.c that if the image had an empty segment
  it would think that mach_header was in that segment.  The change was to the
  logic that set mach_header_segment_vmaddr from the picked up segment's
  vmaddr.  Radar bug #2931784.

Changes for the 5.10 release (the cctools-418 release):
- Changed the code in images.c that was involved in searching for libraries to
  exclude filenames that stat(2) returns true but are not regular files.
  Radar bug #2917660.

Changes for the 5.10 release (the cctools-417 release):
- Turned off fix_prebinding when any of the DYLD PATH or INSERT environment
  variables are set.  Radar bug #2921735.

Changes for the 5.10 release (the cctools-416 release):
- Removed the boolean parameter "and_weak" to is_section_coalesced() in
  symbols.c .  Updated the calls to not pass the extra parameter. Radar bug
  #2919646
- Changed the routine is_symbol_coalesced_and_weak() in symbols.c to test the
  N_WEAK_DEF bit of a symbol and not use the "and_weak" boolean parameter to
  is_section_coalesced(). Radar bug #2919646

Changes for the 5.10 release (the cctools-415 release):
- Re-fixed the problem with the calls to free() in load_library_image() in
  images.c.  The approach to handling the memory of a dynamic libarary name
  passed to load_library_image() has been changed.  The parameter was renamed
  to passed_dylib_name and an automatic for dylib_name was added.  Then the
  functionality of load_library_image() was changed to always free()
  passed_dylib_name is it was not NULL.  Then the call to load_library_image()
  in load_executable_image() in images.c for DYLD_INSERT_LIBRARIES was changed
  to allocate the dynamic libarary name passed.  And the call to
  load_library_image() in _dyld_NSAddImage() in dyld_libfuncs.c was changed
  to not call free() on the value passed in the the case of error returns.
  Radar bug #2892860.
- Changed get_library_name() in images.c to deal with incorrect library names
  of the form "libSystem.B_debug.dylib".  Radar bug #2906863.
- Changed "yeild" in lock.c to "yield".

Changes for the 5.10 release (the cctools-414 release):
- Changed link_library_module() and link_object_module() in symbols.c to deal
  with weak coalesced symbols.  Radar bug #2898558.
- Added the routine is_symbol_coalesced_and_weak() in symbols.c to test for
  weak coalesced symbols.  Radar bug #2898558.
- Added the boolean parameter "and_weak" to is_section_coalesced() in symbols.c
  to check for weak coalesced sections.  Updated the existing calls to pass the
  extra parameter as FALSE.  Radar bug #2898558.
- Changed the two calls to mach_host_self() in dyld_init.c and lock.c to
  call mach_port_deallocate() on the port after the calls.  Radar bug #2895931.
- Changed the Makefile to use the seg1addr 8fe00000 not 7fe00000 for the
  post-Puma address.  Radar bug #2897418.
- Fixed a problem with the calls to free() in load_library_image() in images.c .
  Radar bug #2892860.
- Turned off dyld_trace for the final Mac OS X 10.2 release.  Radar bug
  #2859113.

Changes for the 5.10 release (the cctools-413 release):
- Changed the Makefile to use the seg1addr 7fe00000 not 7ffc0000 for the
  post-Puma address.

Changes for the 5.10 release (the cctools-412 release):
- Changed dyld to malloc a copy of the DYLD_INSERT_LIBRARIES environment
  variable, and changed load_executable_image() to not restore the colon's
  so gdb can see null terminated strings.  Radar bug #2882739.
- Fixed a bug in check_image() in images.c in the error handling code for
  unknown load commands with the LC_REQ_DYLD bit set.  Radar bug #2882932.

Changes for the 5.10 release (the cctools-411 release):
- Changed the Makefile to use the seg1addr 7ffc0000 after Puma and 41300000
  for Puma and earilier releases (Radar bug #2848945).
- Took the hacks out of the end of pickup_environment_variables() that have
  the stack address in it.
- Removed the dummy versions of __isinfd(), __isnand() and __inf() from
  dyld_init.c as these symbols were put back in libc.a .

Changes for the 5.10 release (the cctools-410 release):
- Added dummy versions of __isinfd(), __isnand() and __inf() to dyld_init.c to
  deal with this symbols being moved out of libc.a .

Changes for the 5.10 release (the cctools-409 release):
- Picked up the second prototype code for notify_prebinding_agent() in images.c.
  This also effected dyld_init.c and dyld_init.h in picking up the environment
  variable DYLD_NO_FIX_PREBINDING (Radar bug #2870411).
- Fixed a bug in the code that implements __initialize_Cplusplus() in
  _dyld_call_module_initializers_for_dylib() in mod_init_funcs.c where it was
  not calling the module init routines for modules in the LINKED state after
  delay_mod_init is FALSE (Radar bug #2869388).

Changes for the 5.10 release (the cctools-408 release):
- Picked up the first prototype code for notify_prebinding_agent() in images.c.
  As part of this the definition of executables_pathlen from
  create_executables_path() in images.c as a local to global in dyld_init.c .
  (Radar bug #2866348).

Changes for the 5.10 release (the cctools-407 release):
- Removed support for lazy_inits using a second thread via the Mach 3.0
  exception API's.  Most of these changes are in images.c and other changes were
  in mod_init_funcs.c, symbols.c, images.h, trace.h and errors.h.
  The original Radar bug that this was added under was #2490396.  The radar
  for the removal of this code is #2864021.

Changes for the 5.10 release (the cctools-404 release):
- Fixed a bug in _dyld_NSLookupSymbolInImage() when setting the image name in
  error message when the image is an object image (Radar bug #2857197).

Changes for the 5.10 release (the cctools-402 release):
- Changed the Makefile to use -lgcc for -lcc_dynamic when CC is gcc3.

Changes for the 5.10 release (the cctools-400 release):
- Changed the Makefile back to again use the -dependency-file with gcc.
- Added the new constant DYLD_TRACE_notify_prebinding_agent to trace.h and used
  it in notify_prebinding_agent().
- Added the new function notify_prebinding_agent() for support of prebinding on
  demand in images.c .
- Added two calls to the new function notify_prebinding_agent() in
  map_library_image(), one call in validate_library(), one in
  set_images_to_prebound(), two in set_prebound_state(). These changes are in
  images.c .

Changes for the 5.10 release (the cctools-397 release):
- Turned on DYLD_TRACE for Jaguar development.  Radar bug #2836321.
- Fixed a bug in trace_with_string() that was doing
	if(name != NULL){
  where it should have been doing
	if(name == NULL){
  which caused it to crash doing a strlen() when DYLD_TRACE was turned on.
- Added _dyld_NSGetExecutablePath() to dyld_libfuncs.c as the dyld side of
  _NSGetExecutablePath.  Radar bug #2432816.

Changes for the 5.10 release (the cctools-396 release):
- Changed the use of N_WEAK_SYM to N_WEAK_REF in symbols.c .
- Changed the Makefile to not use the -dependency-file with gcc as well as
  mwccppc.
- Fixed trace_with_string() in trace.c for a compiler warning that was using
  i++ logic incorrectly on passing prameters to syscall().

Changes for the 5.10 release (the cctools-393 release):
- Added the support for weak libraries (LC_LOAD_WEAK_DYLIB) and weak symbols
  (N_WEAK_SYM).

  Added the following three structs for supporting weak symbols declared in
  images.h and defined in images.c
    extern const struct library_image some_weak_library_image;
    extern const struct nlist some_weak_symbol;
    extern const module_state some_weak_module;
  The struct some_weak_symbol is an absolute symbol with the value of zero that
  is used as the definition for all missing weak symbols.

  In load_executable_image() in images.c added the case for LC_LOAD_WEAK_DYLIB
  that does nothing since it has the LC_REQ_DYLD bit set.

  Changed the code in load_library_image() in images.c that deals with a library
  that can't be opened and have it check the dylib_command struct passed to it
  for LC_LOAD_WEAK_DYLIB.  And if it is LC_LOAD_WEAK_DYLIB then fill in the
  image_pointer with &(some_weak_library_image.image) and not call
  system_error() and link_edit_error() but still return FALSE.

  Changed and load_images_libraries() in images.c to treat LC_LOAD_WEAK_DYLIB
  the same as LC_LOAD_DYLIB in the first loop to count dependents.  And in the
  second look to allow the call to load_library_image() to return FALSE and do
  nothing for LC_LOAD_WEAK_DYLIB commands.

  Changed all_dependents_twolevel_prebound() and check_time_stamp() in images.c
  to treat LC_LOAD_WEAK_DYLIB the same as LC_LOAD_DYLIB.

  Added the new routine get_weak() who's return value is to be used as the
  new boolean parameter weak_symbol to lookup_symbol() in symbols.c. weak_symbol
  when TRUE indicates the symbol is weak and can be missing.  If missing the
  weak symbol with the absolute address of zero is to be used.
  Changed lookup_symbol() to check for primary_image being a missing weak
  library and also return the absolute address zero weak symbol.
  Changed lookup_symbol() to check the weak_symbol parameter if the symbol can't
  be found (both two-level and flat lookups) and if TRUE return the values for
  the absolute address zero weak symbol.

  Changed all the callers of lookup_symbol() to pass the new weak_symbol
  parameter using get_weak() or FALSE.

  Changed resolve_undefineds() in symbols.c to not change the name feild of the
  defined symbol_list struct for a weak symbol that was returned as
  some_weak_symbol.

Changes for the 5.10 release (the cctools-387 release):
- Added support for NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME to
  NSAddImage.
  - Broke out the NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME option in
    _dyld_NSAddImage() in dyld_libfuncs.c .
  - The new routine is_library_loaded_by_matching_installname() was added to
    images.c to compare filenames with install names for libraries that were
    marked with match_filename_by_installname.
  - Added the parameter match_filename_by_installname to load_library_image()
    in images.c and changed the calls in dyld_libfuncs.c and images.c to pass
    the new parameter.
  - Added the parameter match_filename_by_installname to map_library_image()
    in images.c and changed the calls in images.c to pass the new parameter.
  - The match_filename_by_installname field was added to the image struct in
    images.h .

Changes for the 5.10 release (the cctools-385 release):
- Picked up changes for the dyld tracing.  These were the files effected:
  trace.h, trace.c, symbols.c, register_funcs.c, mod_init_funcs.c, images.c,
  dyld_libfuncs.c, dyld_init.c, and Makefile.  This is for MacOS X feature data
  base entry 6055 "dyld performance tools/metrics to measure progress".

  Changed the name of kdebug_lookup() to trace_with_string() in trace.c and
  trace.h.

  Added #ifdef's for NO_DYLD_TRACING in trace.h and trace.c to turn off tracing
  for older platforms that don't support this.

  Added #import <unistd.h> to trace.h so to pickup the prototype for syscall()
  to remove compiler warnings about implicit definitions.

  The new files trace.c and trace.h were added to the Makefile.

Changes for the 5.9 release (the cctools-383 release):
- Changed _dyld_NSLookupSymbolInImage() and _dyld_NSIsSymbolNameDefinedInImage()
  in dyld_libfuncs.c to do flat lookups if force_flat_namespace is set and the
  image is not private.  Radar bug #2731330.

Changes for the 5.9 release (the cctools-381 release):
- Added support for the new LC_REQ_DYLD bit in the load command that marks a
  load command required to be understood by the dynamic linker for proper
  execution.  Code to check for this bit was added in load_executable_image()
  and check_image() in images.c .

Changes for the 5.9 release (the cctools-379 release):
- Changed call_module_initializers_for_library() in mod_init_funcs.c to continue
  if the image has no S_MOD_INIT_FUNC_POINTERS section. Changed
  _dyld_mod_term_funcs() in mod_init_funcs.c in the loop for dynamic libraries
  to continue if the image has no S_MOD_TERM_FUNC_POINTERS section.  This is to
  avoid touching link edit pages of libraries.  Radar bug #2732714.

Changes for the 5.9 release (the cctools-377 release):
- Fixed a bug in all_dependents_twolevel_prebound() in images.c when
  DYLD_IMAGE_SUFFIX is used.  The loop to get the dependent image from the
  LC_LOAD_DYLIB load command was comparing install names to get the dependent
  image.  This was changed to used the dependent_images[] array which was set
  up when the dependent images were loaded.  Radar bug 2724475

Changes for the 5.9 release (the cctools-375 release):
- Changed the debug printing of sub-images in load_dependent_libraries() in
  images.c to print them without testing the for the MH_TWOLEVEL flag.  Since
  the sub-images are always set up this should be printed.

Changes for the 5.9 release (the cctools-374 release):
- Fixed inline_bsearch_toc_with_index() in inline_bsearch.h which was basicly
  totally broken unless the hint was not used or exactly right.
- Fixed a bug in the code that was added in lock.c in cctools-370 Radar bug
  #2704241. The bug was after a fork on the child side of fork(), the
  cached_thread port is no longer valid and could have been re-used by 
  another Mach call (like mach_port_allocate()), but dyld called
  mach_port_deallocate() on it anyway.  The fix was to make cached_thread and
  cached_stack global in lock.c and set them to MACH_PORT_NULL and 0 in
  _dyld_fork_child() in dyld_libfuncs.c .  Radar bug #2716915.
- Fixed a bug in all_dependents_twolevel_prebound() in images.c that was doing
  a strcmp() of the file name:
	q->images[j].image.name
  not the install name:
	(char *)q->images[j].dlid + q->images[j].dlid->dylib.name.offset
  Also fixed this same problem of doing a a strcmp() of the file name and not
  the install name in call_dependent_init_routines() in images.c

Changes for the 5.9 release (the cctools-371 release):
- Fixed a typo in unload_remove_on_error_libraries() in images.c where this:
	memset(library_image,'0',sizeof(struct library_image));
  should have been this:
	memset(library_image,'\0',sizeof(struct library_image));
- Removed the code in lookup_symbol_in_library_image() and
  lookup_symbol_in_object_image() both in symbols.c that was "ifdef remove".
- Fixed setup_prebound_coalesed_symbols() in symbols.c to also check when the
  image's symbol on the being linked list does not match the image it is about
  to relocate to make sure the image it is about to relocate is not two-level or
  force_flat_namespace is TRUE.  This was a changed for the object image and the
  library images (2 places).

- Changed dyld to used the twolevel hints.  Radar bug #2558069.

  Added dyld_hints_debug to dyld_init.c set by the evnironment variable
  DYLD_HINTS_DEBUG.

  Changed all the callers of lookup_symbol() to pass a value for the new
  hint parameter.  If the caller passed NULL for the primary_image parameter
  it also passes NULL for the new hint parameter.  If the caller passed the
  return value of get_primary_image() for the primary_image parameter then it
  passes the return value for get_hint() (called with the same image and symbol
  as get_primary_image()).  In the other callers that were looking up in a
  specific image NULL was passed as the hint.

  Added the routine get_hint() to symbols.c to return the twolevel_hint for
  a given image and symbol.

  Changed lookup_symbol() in symbols.c to take a new third parameter:
    struct twolevel_hint *hint, /* the two-level hint if not NULL */
  and added the code to use the hint to lookup the symbol in the hinted
  sub-image and use the hinted itoc.

  Changed lookup_symbol_in_library_image() in symbols.c to take a new second
  parameter:
    unsigned long itoc,		/* hint of index into the table of contents */
  and changed it to call inline_bsearch_toc_with_index().

  Added inline_bsearch_toc_with_index() to inline_bsearch.h.

  Added setting the images_can_use_hints bit to load_executable_image() in
  images.c and _dyld_link_module() in dyld_libfuncs.c .

  Changed setup_sub_images() in images.c to set the images_can_use_hints bit 
  and the subs_can_use_hints bit in the image struct when the hints can be used.

  Changed _dyld_link_module() in dyld_libfuncs.c to call
  load_dependent_libraries() after it called map_bundle_image().  With this the
  call to load_dependent_libraries() was removed from the top of
  link_in_need_modules() in symbols.c .

  Added the hints_cmd parameter to map_image() in images.c and changed the
  callers to pass it and store it in their image struct on return.
  Also changed load_executable_image() in images.c to also pick up and store
  the hints_cmd in the image struct.

  Added a new field and two new bits in the image struct in images.h:
    struct twolevel_hints_command/* The twolevel hints command for the image */
	*hints_cmd;
      image_can_use_hints:1,	/* set when the hints are usable in this image*/
      subs_can_use_hints:1,	/* set when the hints are usable for images */
				/*  that have this image as a sub image */

Changes for the 5.9 release (the cctools-371 release):
- Integrated the changes to use two-level prebound libraries.

  In _dyld_init() in dyld_init.c a call to the new routine
  find_twolevel_prebound_lib_subtrees() is done when prebinding is FALSE.

  Also changed picking up DYLD_PREBIND_DEBUG so the value of "3" is also
  picked up. Which is used for more detailed internal debugging of two-level
  prebound libraries code.

  The new routines:
    all_dependents_twolevel_prebound()
  and
    find_twolevel_prebound_lib_subtrees()
  were added to images.c which do the main of the work of correctly setting
  the two-level prebound state of the libraries.

  Changed undo_prebinding_for_library() in images.c to contionally undo the
  prebinding of the lazy symbols and set the state to PREBOUND_UNLINKED if
  the library has subtrees_twolevel_prebound set to FALSE.  If the field
  subtrees_twolevel_prebound is TRUE then the modules are set to the
  FULLY_LINKED state and the FULLYBOUND_STATE is set

  Changed try_to_use_prebound_libraries() in images.c to return and set
  prebinding to FALSE and return if force_flat_namespace is FALSE and there is
  one two-level library.  This is so that the caller, dyld_init(), can call
  find_twolevel_prebound_lib_subtrees() instead in this case.

  Two new bits were used in the image struct in images.h:
      subtrees_twolevel_prebound_setup:1, /* state of this and deps setup */
      subtrees_twolevel_prebound:1, /* this and deps twolevel and prebound */
  And the prototype to the new routine in image.c was added to images.h:
    extern void find_twolevel_prebound_lib_subtrees(
	void);

Changes for the 5.9 release (the cctools-370 release):
- Changed dyld_mach_thread_self() in lock.c to call mach_port_deallocate() on
  the cached_thread before changing it to not leak a port right.  Radar bug
  #2704241.

Changes for the 5.9 release (the cctools-369.2 release):
- Changed setup_sub_images() in images.c to reset the umbrella_images_setup
  field of any sub image to FALSE to force the umbrella_images it to be
  recreated as a new umbrella for an existing library could be added after
  the umbrella_images were first set up.  Radar bug #2706662.

Changes for the 5.9 release (the cctools-369.1 release):
- Changed _dyld_NSLookupSymbolInImage() and _dyld_NSIsSymbolNameDefinedInImage()
  in dyld_libfuncs.c to allow it to handle mach headers from object file images.
- Fixed again the bug in _dyld_NSLookupSymbolInImage() in dyld_libfuncs.c where 
  it was not working when called from an init routine.   The problem was it was
  unconditionally calling link_library_module() and this was causing it to set
  the link_state back to BEING_LINKED from its REGISTERING state.  This caused
  things to be relocated twice so address of symbols would have twice their
  value.

Changes for the 5.9 release (the cctools-369 release):
- Fixed a bug in _dyld_NSLookupSymbolInImage() in dyld_libfuncs.c where it was
  testing GET_FULLYBOUND_STATE(*defined_module) and returning when it was
  set.  It turns out this can be set when the link_state is REGISTERING when
  called from an init routine.

Changes for the 5.9 release (the cctools-367 release):
- Added support for sub-libraries like sub-umbrellas.  Radar bug #2697458.

  Added the following field to the image struct:
    char *library_name; 
  and changed the of the following field from umbrella_name_size to:
    unsigned long name_size;    
  for use both by umbrella_name and library_name.  The code in errors.c and
  images.c was changed to use the new field name.

  Added a get_library_name() routine like get_framework_name() to images.c and
  a call to get_library_name() from map_library_image() in images.c .

  In load_dependent_libraries() in images.c change it to used library_name when
  not NULL for DYLD_TWO_LEVEL_DEBUG printing.

  In setup_sub_images() in images.c changed the header comments to include
  sub-libraries and added code to deal with sub-libraries like sub-umbrellas.

- Added some code in load_dependent_libraries() in images.c when
  DYLD_TWO_LEVEL_DEBUG is set to print out the flat library order.  Also some
  minor code changes and comment changes.  Radar bug #2558069.

Changes for the 5.9 release (the cctools-366 release):
- Fixed a problem with undefined symbol references from two-level images where
  the definition of the symbol is in a sub-framework of a flat namespace
  umbrella framework that would come up undefined.   The fix was in
  load_images_libraries() in images.c for the setting up of the pointers to
  dependent images no longer being conditional on the image being MH_TWOLEVEL. 
  And in load_dependent_libraries() in images.c the call to setup_sub_images()
  is also longer conditional on if the image is MH_TWOLEVEL. 

Changes for the 5.9 release (the cctools-365 release):
- Fixed a bug in resolve_undefineds() in symbols.c when return_on_error is
  set and the prebinding was undone for a prebound library module and the
  saved module state was assigned to UNLINKED where it should have used the
  macro SET_LINK_STATE().  This same problem is also in link_library_module()
  in symbol.c in two places also. Radar bug #2665925.
- Added the routine clear_module_states_saved() to symbols.c that is called 
  in _dyld_link_module() in dyld_libfuncs.c when return_on_error is set to
  true and called in _dyld_NSLookupSymbolInImage() in the same case.  This is
  needed to fix a potential bug where a previoully saved state could later get
  incorrectly restored.  This could be part of the cause of Radar bug #2665925.
- Added _dyld_NSAddImage(), _dyld_NSLookupSymbolInImage() and
  _dyld_NSIsSymbolNameDefinedInImage() to dyld_libfuncs.c .
  As part of this is_library_loaded_by_name() and is_library_loaded_by_stat() in
  images.c were changed from static to extern functions.  Also as part of this
  the new DYLD_INVALID_ARGS dyld_other_error_numbers enum in errors.h was added
  and the matching NSOtherErrorInvalidArgs in the NSOtherErrorNumbers enum in
  <mach-o/dyld.h> was added.  Radar bug #2689833.

Changes for the 5.9 release (the cctools-364 release):
- Changed call_dependent_init_routines() in images.c to set init_called for
  shared libraries that don't have init routines so they are not visted more
  than needed by the code.  Also init_called is tested for FALSE before calling
  call_dependent_init_routines() recursively.  Radar bug #2686444.
- Fixed a bug in the external_relocation() routines in all the *_reloc.c files
  when dealing with an prebound dylib that has nmedit(1) run on it.  What
  happens is nmedit(1) produces a file with external relocation entries for
  non-external symbols that were private_extern symbols.  Then when
  undo_external_relocation() sees a relocation entry with this symbol it
  correctly undoes the relocation because it does not need to lookup the symbol.
  But when external_relocation() see the entry it does lookup the symbol and
  fails to find it as it is not an external symbol and undoes the relocations it
  did for that module and returns.  The fix was to test the symbol type for a
  non-external symbols that was a private_extern and if so use the symbol from
  the image (just like coalesced symbols in private images).  Radar bug
  #2676317.
- Fixed a bug in is_library_loaded_by_name() in images.c where if the library
  name is not a full path we can't match by name if the program was already
  launched as it could be the same name as a library already loaded but be a
  different library if the current working directory changed. So code was added
  to return FALSE in this case and let it be opened and checked to be the same
  if the stat(2) info is the same.
- Fixed a bug in the case when a module in a prebound library is later used
  that was not part of the prebound set that calls another prebound library
  that was not part of the prebound set and the module initialization would
  not get run.  This happens because the prebound lazy pointers of the module
  that gets bound in later are not reset to cause it to call dyld.  The case
  that the Radar ran into was when all modules in the library were not part of
  the prebound set.  For this some code in set_prebound_state() was added that
  calls undo_prebound_lazy_pointers() to undo the prebinding of the lazy symbols
  pointers for libraries that don't have any modules used and the new field
  undone_prebound_lazy_pointers is then set to TRUE. For the harder case when
  some of the modules are part of the prebound set then a fair bit of code in
  undo_prebinding_for_library_module() in relocs.c was added which calls the
  new routine reset_lazy_symbol_pointers() also in relocs.c.  That new routine
  then calls undo_prebound_lazy_pointers() which was changed to take two new
  parameters to allow it to undo only the needed pointer.  The callers of
  undo_prebound_lazy_pointers() were also updated.  Radar bug #2650066.
- Fixed a bug in search_for_name_in_path() in images.c that cause it to crash
  if the DYLD_LIBRARY_PATH ended in a ':'.  Radar bug #2676732.

Changes for the 5.9 release (the cctools-363 release):
- Picked up the change suggested in Radar bug #2667248 which removes one
  clear_lock() and try_to_get_lock() loop pair in set_lock() in lock.c .
- Picked up the change suggested in Radar bug #2667241 which added a 
  dyld_mach_thread_self() call to lock.c to improve preformance by caching the
  last value of the mach_thread_self() call against the page truncated stack
  address making the call.

Changes for the 5.9 release (the cctools-361 release):
- Fixed a bug in load_dependent_libraries() in images.c that was only calling 
  setup_umbrella_images() if the library was a MH_TWOLEVEL.  This needed to
  call setup_umbrella_images() for all libraries as it is possible that a
  sub-framework of an umbrella library is flat and the umbrella library is
  two-level.  In that case other images could have two-level namespace
  references recorded to the umbrella library for symbols defined in the flat
  sub-framework.  This happened with the umbrella library ApplicationServices
  and its subframework ATS when the two-level library libCGATS was referencing
  _gImagePathAGPtr from ApplicationServices.  Then what happened is the code in
  relocate_symbol_pointers_in_library_image() did not match up the symbol on
  the being linked list for _gImagePathAGPtr defined in ATS because it did not
  have any umbrella images.
- Fixed a bug in lookup_symbol() in symbols.c in the case of a two-level name
  space lookup drops into the sub images loop the outer_object_image was
  set wrong.  It was a copy and paste error using:
	primary_image->outer_image;
  when it should have been using:
	primary_image->sub_images[i]->outer_image;
  This caused a bogus multiply defined error stating the same module defined
  the same symbol.  As link_library_module() thought the symbol was defined
  in different modules because the prev_module did not match the module
  returned by the look up.  The symbol that was getting the multiple definitions
  error was _identityMatrix in ATS(ATS.link2.o).  The symbol actually being
  looked up was _INIT_ATS but looked up in the umbrella framework
  ApplicationServices.  In this case ATS was flat and ApplicationServices was
  two-level.  The lookup of _INIT_ATS was from libCGATS.A.dylib which was
  two-level.
- Fixed another bug in add_reference() in symbols.c when there was a
  symbol_list entry on the being linked list that had flat_reference == FALSE.
  In this case an extra test was needed to check the incoming flat_reference
  and if it was TRUE and the being_linked->flat_reference == FALSE then set the 
  being_linked->flat_reference to TRUE.  This caused things using the flat
  reference not to have their symbol pointers set.  This was found with the
  symbol _kCFAllocatorSystemDefault and Sherlock and using a two-level
  CoreFoundation and a flat QD when the non-lazy pointer in QD was not getting
  set.
- Fixed a bug in add_reference() in symbols.c where a symbol was on the being
  linked list with a flat_reference == TRUE and later that symbol needs to be
  fully bound which is has flat_reference == FALSE.  Then flat_reference bit
  gets lost as the symbol is taken off the being linked list and then put back
  on the undefined list.  This causes things using the flat reference not to be
  relocated.  This was found with errno and a PB and a two-level libSystem
  because libobjc.A.dylib has a library init routine ___initialize_objc which
  has to be fully bound.

Changes for the 5.9 release (the cctools-360 release):
- Changed the size of _symbol_blocks in section_order.s to match the 'C'
  struct size.  This should have been done when the flat_reference field was
  added to the struct symbol_list.
- Added an outer_image field to the image struct to point back to the
  library_image or object_image so that for two-level namespace lookups the
  library_image or object_image can be quickly obtained from the image structure
  for calls to lookup_symbol_in_library_image() or
  lookup_symbol_in_object_image().  This is filled in by map_library_image(),
  map_bundle_image() and load_executable_image() in images.c.  Then changed
  lookup_symbol() in symbols.c to use this field and removed the hacked code in
  lookup_symbol_in_library_image() and lookup_symbol_in_object_image() to
  figure out the values if they were NULL.  Along with this change was the
  change to lookup_symbol() itself for the flat lookup to also use the sub
  routines lookup_symbol_in_library_image() and lookup_symbol_in_object_image().

Changes for the 5.9 release (the cctools-359 release):
- Added a check in map_library_image() in images.c to disable prebinding if 
  we are forcing flat name space and we have a two-level namespace library.
- Fixed a bug in link_library_module() and link_object_module() in symbols.c
  for the checking of multiply defined symbols where this was part of the
  expression:
		(prev_image->mh->flags & MH_TWOLEVEL) != MH_TWOLEVEL){
  that should have been this:
	       (force_flat_namespace == TRUE ||
		(prev_image->mh->flags & MH_TWOLEVEL) != MH_TWOLEVEL)){
- Removed the following PowerPC sync instruction in try_to_get_lock():
	sync		; Fix for 3.2 and older CPUs
  Radar bug #2615783.
- Added -Wno-long-double to shutup the compiler for
  <architecture/m88k/fp_regs.h>.
- Added a call to clear_lock(global_lock) in _dyld_fork_child() in
  dyld_libfuncs.c in case another thread in the parent got it while we were
  fork'ing.
- Changed the name of look_for_reference() to look_for_flat_reference() and
  changed the name of change_symbol_pointers_in_images() to 
  change_symbol_pointers_in_flat_images().  Then added code in there to only
  look at flat images and these should only be used for updateing flat images.
- Added the flat_reference parameter to add_to_being_linked_list() in symbols.c
  and changed the callers to pass it so that it is set correctly for symbols
  being used from already bound images.  This is needed so that
  relocate_symbol_pointers() knows which symbol pointers to update from the
  symbols in the being linked list.
- Changed resolve_undefineds() in symbols.c to call the lookup_symbol() routine
  based on the type image in the undefined list (flat or two-level) by using
  get_primary_library().
- Changed relocate_symbol_pointers_in_object_image() and 
  relocate_symbol_pointers_in_library_image() in symbols.c to deal with setting
  symbol pointer values correctly based on the images for the symbols on the
  being linked list for two-level images.  And also only using symbols on the
  being linked list for flat images that have flat_reference set.
- Changed the code in check_and_report_undefineds() in errors.c for the
  reporting undefined symbols so that when a two-level bound symbol can't be
  found the the image making the reference and the image with the expected
  definition is printed along with the symbol name.
- Changed the way link_library_module() and link_object_module() in symbols.c
  handles multiply defined symbols when two-level namespace linking so that it
  does not print an error.  The approach taken for global coalesced symbols in
  a two-level namespace image currently is to use the definition in the image
  for those references.  To allow global coalesced symbols to work but to not
  check for multiple defined symbols link_library_module() has a test for doing
  two-level namespace linking for the image. Then a loop to add the global
  coalesed symbol is done before skiping over the multiply defined symbol check
  with a goto add_undefineds.  The same thing is already done in
  link_object_module() for private images and that is simply used for two-level
  namespace linking as well.
- A first cut at the new part of the lookup_symbol() routine was written
  to do the two-level namespace lookup using the primary_image and the
  sub-images of the primary_image.  Factored out two new routines
  lookup_symbol_in_object_image() and lookup_symbol_in_library_image() to do
  the work lookup_symbol does looking up a symbol in a single image.   Still
  will need to make a major change to move the the library_image struct fields
  nmodules and modules as well as the object_image struct field module to the
  struct image.  So they can be gotten to via the arrays of image pointers.
  This involves changing lots of code so this so it will wait till things are
  working some what.
- Added the primary_image parameter lookup_symbol() in symbols.c for use
  when doing two-level namespace lookups.  This prameter is usually a call to
  get_primary_image() or NULL.  Updated all the call sites of lookup_symbol()
  to added the correct value of primary_image.  Also update all the places
  N_INDR symbols are handled to get the correct primary_image before calling
  lookup_symbol().
- Added the static "inline" (not yet) routine get_primary_image() it symbols.c
- Added the enum bool flat_reference parameter to the static routine
  add_to_undefined_list() in symbols.c and changed all the call sites to pass
  the correct value for flat_reference based on the type of reference.
- Added the following field to the symbol_list struct in symbols.h for
  supporting two-level and flat namespace references:
    enum bool flat_reference;	/* symbol is for a flat namespace reference */

- Added the code in images.c to set up the two-level namespace images lists.
  This is done in with the new routines setup_sub_images(), 
  setup_umbrella_images(), allocate_image_pointers(),
  reallocate_image_pointers() and deallocate_image_pointers().
  With other changes in load_images_libraries(), load_dependent_libraries() and 
  load_library_image().
- Added the variable force_flat_namespace and the setting of it in dyld_init()
  in dyld_init.c based on MH_FORCE_FLAT in the executable's header or the
  environment variable DYLD_FORCE_FLAT_NAMESPACE.
- Added the following fields to the image struct in images.h for supporting
  two-level namespace:
      ...
      sub_images_setup:1,	/* the sub images have been set up */
      umbrella_images_setup:1,  /* the umbrella_images have been set up */
      ...
    /*
     * For two-level namespace images this is the array of pointers to the
     * dependent images and the count of them.
     */
    struct image **dependent_images;
    unsigned long ndependent_images;
    /*
     * If this is a library image which has a framework name then this is the
     * part that would be the umbrella name and the size of the name.  This
     * points into the name and since framework names may have suffixes the size
     * is needed to exclude it.  This is only needed for two-level namespace
     * images.  umbrella_name will be NULL and umbrella_name_size will be 0
     * if there is no umbrella name.
     */
    char *umbrella_name;
    unsigned long umbrella_name_size;

    /* array of pointers to sub-frameworks and sub-umbrellas and count */
    struct image **sub_images;
    unsigned long nsub_images;
    /* array of pointers to back to umbrella frameworks and sub-umbrellas
     if any which the image is a part of and the count of them. */
    struct image **umbrella_images;
    unsigned long numbrella_images;

Changes for the 5.8 release (the cctools-358 release):
- Fixed a bug in link_object_module() in symbols.c where when loading a module
  privately with coalesced symbols the loop does not check the value of the
  indirect symbol table entry against INDIRECT_SYMBOL_LOCAL and
  INDIRECT_SYMBOL_ABS before using the value as in index into the symbol table.
  Radar bug #2631405.

Changes for the 5.8 release (the cctools-357 release):
- Changed the Makefile from using:
	LIBC = -L$(NEXT_ROOT)$(SYSTEMDIR) -lc -lcc_dynamic
  to:
	LIBC = $(NEXT_ROOT)$(SYSTEMDIR)/libc.a -lcc_dynamic
  because some where between Cheetah1K16 and Cheetah1K19 a symbolic link
	/usr/lib/libc.dylib -> libSystem.dylib
  was created confusing the -lc reference.

Changes for the 5.8 release (the cctools-356 release):
- Moved the call to relocate_symbol_pointers_in_library_image() to the bottom
  of the loop in the routine relocate_modules_being_linked() in reloc.c .
  The thinking is that this could be the cause the failure of the the multi
  threaded java testing program.  Where one thread is in dyld relocating a
  module and another thread gets in via a set lazy pointer then touches an
  item that is not yet relocated and crashes.  Radar bug #2584800.

Changes for the 5.8 release (the cctools-355 release):
- Fixed a bug in relocate_symbol_pointers() where an lazy_init library should
  never have its symbol pointers relocated.  This causes a dead lock in dyld as
  the code in relocate_symbol_pointers() which is holding the lock then causes
  an exception on the symbol pointer that is read-only.  Then the exception code
  trys to get the lock and spins.  The fix is in relocate_symbol_pointers() in
  symbols.c that checks to see if the image has the lazy_init bit set if so it
  just returns.  Radar bug #2582778.
- Fixed the fix to _dyld_NSLookupAndBindSymbolWithHint() in dyld_libfuncs.c
  that was missing the line:
	    link_state = GET_LINK_STATE(*defined_module);
  to set the value of link_state before testing it.  Radar bug #2580180.

Changes for the 5.8 release (the cctools-354 release):
- Fixed a bug in _dyld_NSLookupAndBindSymbolWithHint() and 
  _dyld_lookup_and_bind_with_hint in dyld_libfuncs.c that did not check after
  the symbol was found that is was linked.

Changes for the 5.8 release (the cctools-353 release):
- Added the use_header_dependencies parameter to call_dependent_init_routines()
  in images.c to use the header dependencices instead of the symbol dependencies
  when calling library init routines for the first time in a prebound app.  The
  goal of this is to avoid touching all the symbol tables of all the libraries
  at launch time.  Radar bug #2571628.
- Added lookup_symbol_in_hinted_library() to symbols.c and 
  _dyld_lookup_and_bind_with_hint(), _dyld_NSLookupAndBindSymbolWithHint() and
  _dyld_NSIsSymbolNameDefinedWithHint() to dyld_libfuncs.c that use
  lookup_symbol_in_hinted_library().  Radar bug #2571272.
- Moved the images.h header file to /usr/local/include when RC_OS is macos and
  RC_RELEASE is not Beaker, Bunsen, Gonzo or Kodiak.  Radar bug #2569880.
- Added check_libraries_for_overrides() to symbols.[ch]. Added the library_image
  parameter to check_libraries_for_definition_and_refernce() which skips looking
  at that library_image for symbol definitions and references.
  Changed try_to_use_prebound_libraries() in images.c to call the new routine
  check_libraries_for_overrides().
  Radar bug #2564555.

Changes for the 5.8 release (the cctools-350 release):
- Added support for the new DYLD_NEW_LOCAL_SHARED_REGIONS environment variable
  (Radar bug #2567132).

Changes for the 5.8 release (the cctools-349 release):
- Added inline versions of bsearch routines and strcmp.  These are in the files
  inline_bsearch.h and inline_strcmp.h.  The inline strcmp() routine is in 
  gnu 2.95 syntax for PowerPC only. (Radar bug #2558068).
- Changed where the pointer to the mach_header field, mh, is in struct image to
  match <mach-o/dyld_gdb.h>.  As well as where the nimages field is in the
  object_images and library_image structs to also match <mach-o/dyld_gdb.h>.
  Also added a valid field to the image data structure for gdb to use intead of
  exporting the info to have it look at the LINK_STATE for the UNUSED state.
  This is set to TRUE in images.c after the structures are filled in and set
  for FALSE before an image is to be removed.  Added a calls to
  gdb_dyld_state_changed() at the end of load_executable_image() in images.c
  and at the end of _dyld_link_module(), _dyld_unlink_module() and
  _dyld_NSAddLibrary() in dyld_libfuncs.c .  Radar bug #2559324.

Changes for the 5.8 release (the cctools-347 release):
- Added the support for _dyld_register_func_for_remove_image() in dyld.  This
  effected register_funcs.{c,h} and images.c.  Also added the missing calls
  to send_event() for libraries that were removed.  Radar bug #2553324.
- Added the support for NSAddLibraryWithSearching() in dyld.  This was basicly
  adding a enum bool force_searching parameter to load_library_image().  Radar
  bug #2535633.

Changes for the 5.8 release (the cctools-346 release):
- Changed unload_remove_on_error_libraries() in images.c call a newly added
  static routine unload_shared_file() which calls the new kernel api
  reset_shared_file().  Radar bug #2549068.

Changes for the 5.8 release (the cctools-345 release):
- Changed unload_remove_on_error_libraries() in images.c to not vm_deallocate()
  the memory of a split library.  It currently prints a message saying it can't
  unload the library.  Radar bug #2544696.
- Added the ifdef __HERA__ for MacOS X Server in images.c as it was using
  __GONZO_BUNSEN_BEAKER__ which was really not right.  Also changed the comment
  in the top level Makefile.  This effected the files debug.c, mod_init_funcs.h,
  mod_init_funcs.c, dyld_init.h, dyld_init.c and images.c .

Changes for the 5.8 release (the cctools-341 release):
- Changed link_library_module() and link_object_module() in symbols.c to also
  not check for multiply defined symbols when the link_state of the module is
  in the BEING_LINKED state as well as the LINKED state.  This is done to fix
  a problem with global coalesced symbols.  It avoids having more than one
  instance of two differen global coalesced symbol on the being_linked_list
  which causes the symbol pointers to be set to the wrong global coalesced
  symbol.  Radar bug #2511358.
- Changed the tests in pickup_environment_variables() in dyld_init.c to allow
  a getuid() of 0 (root) to let the environment variables have effect.  Radar
  bug #2497678.
- Added a call to free() in load_library_image() in images.c in the case that
  is_library_loaded_by_name() returns TRUE and load_library_image() was called
  by NSAddLibrary(), dl == NULL.  Also did the same for the case that
  is_library_loaded_by_stat() returns TRUE.  Radar bug #2504987.
- Changed the value of NLIBRARY_IMAGES in images.h from 10 to 60 based the
  Finder's uses with MacOS X Public Beta (Kodiak1G7).  Also change the value
  of NOBJECT_IMAGES from 40 to 5 based again on the Finder.  Left the value of
  MODULE_STATE_BLOCK_SIZE in images.c at 2000 since this is currently enough
  for the Finder. The value of NSYMBOL_BLOCKS in symbols.c was changed to 45
  from 35 as this is what the Finder needs to launch in its unprebound state.
  Also note that 4 bytes got added to struct symbol_list in symbols.h without
  the value allocated in section_order.s being updated.  This means that the
  value in section_order.s for symbol_blocks was changed from 84280 to 126360.
  Radar bug #2504987.
- Changed the calling of module initialization in images marked with
  MH_LAZY_INIT to also cause them to be run lazily.  Radar bug #2502941.

Changes for the 5.7 release (the cctools-340 release):
- Picked up a change to debug.c that Klee Dienes made to make Radar bug #2487248
  no longer happen.  This involves adding a usleep(20000) to server_loop()
  before it tries to reset the suspend count of the thread.  Added an ifndef
  __GONZO_BUNSEN_BEAKER__ around this as usleep() on MacOS X Server has
  references to dyld functions.

Changes for the 5.7 release (the cctools-337 release):
- In dyld_start.s the stack alignment was changed from this:
	clrrwi	r1,r1,4		; align to 16 bytes
  was changed to this:
	clrrwi	r1,r1,5		; align to 32 bytes
  as it is in start.s in the Csu project.  Radar bug #2495403.

Changes for the 5.7 release (the cctools-336 release):
- Fixed a bug in _dyld_image_containing_address() in dyld_libfuncs.c when a 
  plugin was unloaded.  That code and many other places need to test the module
  state of the object to see if it was unused before looking at the other
  fields.  Radar bug #2493911.

Changes for the 5.7 release (the cctools-335 release):
- Fixed a bug in construct_at_executable_path_library() in images.c where it was
  doing a strncpy() followed by a strcat().  This doesn't work if a NULL is not
  in the string after the strncpy() string as it does not copy the NULL.
  Radar bug #2493400.

Changes for the 5.7 release (the cctools-334 release):
- Added support for lazy_inits using a second thread via the Mach 3.0 exception
  API's.  Most of these changes are in images.c .  Radar bug #2490396.
- Fixed a bug in link_object_module() that could set a module back to the
  BEING_LINKED state when it was in the LINKED or FULLY_LINKED state causing
  it to be relocated twice (also part of Radar bug #2483733).  Also changed
  linked_library_module() to also protect against this case.

Changes for the 5.7 release (the cctools-333 release):
- Changed the call to load_shared_file() in images.c to match the changed
  prototype for Kodiak1E (Radar bug #2484973).

Changes for the 5.7 release (the cctools-332 release):
- Fixed a bug in link_library_module() in symbols.c in the loop to resolve
  private externs the call to link_library_module() should have passed the
  prameters bind_now and bind_fully to the call to link_library_module() not
  always pass them as TRUE.  This caused things to get relocated twice in this
  case a "FILE output_fp = stdout" (Radar bug #2483733).
- Fixed _dyld_image_containing_address() to deal with split dylibs.
  Radar bug #2480801.
- Added setting the cksum field of the sf_mapping structs to zero for now. This
  might be used for the digest sections.
  Radar bug #2480801.
- Added a test for setting up the sf_mapping structs to only create a zerofill
  map if the segment has write protection and the vmsize is greater than the
  file size.
  Radar bug #2480801.
- Changed the call to load_shared_file() to first call it with flags == 0 then
  if that fails call it with flags == ALTERNATE_LOAD_SITE.  Also changed the
  error case to not return(FALSE) but to goto map_image_cleanup1 to clean up
  the mapped memory and open file descriptor.
  Radar bug #2480801.
- Changed the code around load_shared_file() to not subtract constants but
  rather *seg1addr for setting the mapping_offset field.  Also changed it so
  that no address is subtracted from the base_address variable.
  Radar bug #2480801.
- Changed to using SHARED_LIBRARY_SERVER_SUPPORTED instead of
  _SHARED_MEMORY_SERVER_H_ in images.c and removed the code on the other side
  of the ifdef NEW_LOAD_SHARED_FILE and made that the default.
  Radar bug #2480801.
- Fixed a bug in map_image() in images.c with respect to fat files.  The
  file_offset of the mapping structure being set for an LC_SEGMENT can't be
  set to just sg->fileoff but needs to be "sg->fileoff + library_offset".
  Radar bug #2480801.
- To build dyld with -DNEW_LOAD_SHARED_FILE we need new headers from Chris and
  a new libc.a to link against.

  Note the prototype for load_shared_file() was in <mach/mach_traps.h> and now
  is in <bsd/sys/mman.h>.  Also note most of the headers are in BOTH Headers
  and PrivateHeaders.

  I picked this file up from
    cdy1:/SandBox/kev2/75.2/xnu/BUILD/obj/EXPORT_HDRS/osfmk/mach/mach_traps.h
  installed into:
    /System/Library/Frameworks/System.framework/Headers/mach/mach_traps.h
  and into:
    /System/Library/Frameworks/System.framework/PrivateHeaders/mach/mach_traps.h

  I picked this file up from:
    cdy1:/SandBox/kev2/75.2/xnu/BUILD/obj/EXPORT_HDRS/bsd/sys/mman.h
  installed into:
    /System/Library/Frameworks/System.framework/Headers/bsd/sys/mman.h

  I picked this file up from:
    cdy1:/SandBox/kev2/75.2/xnu/BUILD/obj/EXPORT_HDRS/osfmk/mach/
	 shared_memory_server.h
  installed into:
    /System/Library/Frameworks/System.framework/Headers/mach/
	shared_memory_server.h
  and into:
    /System/Library/Frameworks/System.framework/PrivateHeaders/mach/
	shared_memory_server.h

  We added "#define SHARED_LIBRARY_SERVER_SUPPORTED" to
    /System/Library/Frameworks/System.framework/Headers/mach/
	memory_object_types.h
  and also to
    /System/Library/Frameworks/System.framework/PrivateHeaders/mach/
	memory_object_types.h

  Then dyld will build with -DNEW_LOAD_SHARED_FILE.

  Next we must link dyld with a libc that has the correct trap numbers.  To do
  this we need to add syscall stubs to Libc and recompile the Libc project
  against these new headers:

  I picked this file up from
    cdy1:/SandBox/kev2/75.2/xnu/BUILD/obj/EXPORT_HDRS/osfmk/mach/mach_traps.h
  installed into:
    /System/Library/Frameworks/System.framework/Headers/mach/mach_traps.h
  and into:
    /System/Library/Frameworks/System.framework/PrivateHeaders/mach/mach_traps.h

  I picked this file up from
    cdy1:/SandBox/kev2/75.2/xnu/BUILD/obj/EXPORT_HDRS/bsd/sys/syscall.h
  installed into:
    /System/Library/Frameworks/System.framework/Headers/bsd/sys/syscall.h
  and into:
    /System/Library/Frameworks/System.framework/PrivateHeaders/bsd/sys/syscall.h

  I picked this file up from
    cdy1:/SandBox/kev2/75.2/xnu/BUILD/obj/EXPORT_HDRS/osfmk/mach/syscall_sw.h
  installed into:
    /System/Library/Frameworks/System.framework/Headers/mach/syscall_sw.h
  and into:
    /System/Library/Frameworks/System.framework/PrivateHeaders/mach/syscall_sw.h

  The new syscall stubs were done by making a copy of Libc-139 and created the
  files:

  sys.subproj/ppc.subproj/load_shared_file.s
  With this code in it:
	#include "SYS.h"
	SYSCALL(load_shared_file, 7)
	    blr
  where 7 is nargs for the macro SYSCALL as defined in SYS.h.

  sys.subproj/i386.subproj/load_shared_file.s
  With this code in it:
	#include "SYS.h"
	UNIX_SYSCALL(load_shared_file, 7)
		ret

  And changed the sys.subproj/ppc.subproj/Makefile and
  sys.subproj/i386.subproj/Makefile and added load_shared_file.s to the
  OTHERLINKED macro and load_shared_file.o to the OTHERLINKEDOFILES macro.
  And changed sys.subproj/ppc.subproj/PB.project and
  sys.subproj/i386.subproj/PB.project to add load_shared_file.s after listen.s.

    % otool -tV -p _load_shared_file "/usr/local/lib/system/libc.a(mach_traps.o)
    /usr/local/lib/system/libc.a(mach_traps.o):
    (__TEXT,__text) section
    _load_shared_file:
    000000d0        li      r0,0xffcc
    000000d4        sc
    000000d8        blr
  where 0xffcc is -52.

  The recompiled libc will show 
  % otool -tV -p _load_shared_file "/SandBox/Libc-139.roots/Libc-139.dst/usr/
	local/lib/system/libc.a(load_shared_file.o)"
    (__TEXT,__text) section
    __framesize:
    00000000        li      r0,0x12b
    00000004        sc
    00000008        b       0x10
    0000000c        b       0x30
    00000010        mfspr   r0,lr
    00000014        bl      0x18
    00000018        mfspr   r12,lr
    0000001c        mtspr   lr,r0
    00000020        addis   r12,r12,ha16(0x38-0x18)
    00000024        lwz     r12,lo16(0x38-0x18)(r12)
    00000028        mtspr   ctr,r12
    0000002c        bctr
    00000030        nop
    00000034        blr
   where 0x12b is 299.


Changes for the 5.7 release (the cctools-330 release):
- Changed the ifdef's for the DEFAULT_FALLBACK_FRAMEWORK_PATH in dyld_init.h so
  that moving forward /Library/Frameworks is part of the default paths
  and /Local/Library/Frameworks is only used instead if __GONZO_BUNSEN_BEAKER__
  is defined for older DP4, DP3 & PR2 builds.  Radar bug #2477862.
- Fixed a bug in call_dependent_init_routines() in images.c that casued dyld to
  crash when an undefined symbol was detected.  This should not happen in the
  normal case but can happen if an init routine were to unload a module another
  init routine depended on (that unload would have to use RESET_LAZY_REFS as any
  non-lazy reference would cause an error at the time of unloading).  This did
  happen because of the next bug listed below in dyld.  The fix for this bug is
  after the calls to lookup_symbol() where it returns NULL for defined_symbol is
  now tested for an the loop is continued if defined_symbol is NULL. Radar bug
  #2477856.
- Fixed a bug in dyld that did not correctly fully bind the references to a
  shared library init routine if the executable is overridding a symbol that the
  shared library init routine uses. Radar bug #2477856.

  The fix starts in add_reference() in symbols.c when a reference to a symbol
  being passed with fully_bind set to TRUE is looked up and found in a module 
  who's state is already being linked in.  Then the symbol could be either be
  found on the being_linked_list or not. In either case when bind_fully is TRUE
  the FULLYBOUND_STATE needs to be checked.  If the symbol was not found on the
  being linked list then add_to_undefined_list() can simply be called with the
  bind_fully parameter passed.  If the symbol was found on the being linked list
  it needs to be back on the undefined list and have its bind_fully field set to
  TRUE.

  The fix then moves on to resolve_undefineds().  The code that handles when a
  symbol on the undefined_list is looked up and found with fully_bind being
  TRUE was also changed.  This code now just checks fully_bind for TRUE and
  the FULLYBOUND_STATE (without checking if library_image is not NULL).  Then
  inside that "if" another test for library_image being NULL is maded.  If 
  library_image is not NULL then the existing code calling link_library_module()
  is done.  Otherwise a new call to link_object_module() is made to fully_bind
  the object module.

  To allow this "else" branch to call link_object_module() the new routine
  find_object_image() was added.  So than it could get the object_image from
  the image pointer to pass to link_object_module().

  In this "else" branch link_object_module() is called with the new third
  parameter "bind_fully" set to true to rebind the object module fully.

  The code in for link_object_module() in symbols.c was change to take the new
  third parameter "bind_fully".  This parameter is then used in the "if" test
  when adding its undefined references.  The code that added the reference
  to the undefined list or being linked list was removed and a call to
  add_reference() was added in its place to clean things up and avoid
  duplicating this logic.  And lastly this code sets the FULLYBOUND_STATE at
  the end of the routine is bind_fully is TRUE.

  link_object_module() was called in two places in dyld_libfuncs.c (in 
  _dyld_lookup_and_bind_fully() and _dyld_link_module()) and those calls were
  updated to add the third prameter.  Also the prototype in symbols.h was
  updated.

NOTE:
  When return_on_error is set an executable can get fully linked and the
  FULLYBOUND_STATE will get set in link_object_module().

  The undefined symbols that got added when return_on_error was set will get
  correctly removed by clear_undefined_list(TRUE).  Note no non-lazy undefs
  from the executable could be left because the executable is bound at launch
  when return_on_error is FALSE.

  The name of the routine clear_state_changes_to_the_library_modules() was
  changed to clear_state_changes_to_the_modules().

  clear_state_changes_to_the_modules() was change to clear the module
  bit FULLYBOUND_STATE if needed.  Also it clears module_states_saved field
  back to FALSE so a second error will not restore old state.

  The other state bits MODINIT_STATE, MODTERM_STATE or IMAGE_INIT_DEPEND_STATE
  will not get set if an error happens so they don't need to be backed out.
  This is also the case for prebinding so reset_module_states() does not need
  to change these either.

  clear_state_changes_to_the_modules() was changed to clears the link state
  of object modules and the FULLYBOUND_STATE if needed when return_on_error
  happens.  Two new fields saved_module_state and module_state_saved were
  added in the object_image struct.  These get set in resolve_undefineds() just
  like the saved module states for libraries.

- Changed dyld to not used its own processor_has_vec variable and use 
  _cpu_has_altivec from the System framework private header
  <architecture/ppc/processor_facilities.h>. This effected the files Makefile,
  dyld_init.h, dyld_init.c, images.c and mod_init_funcs.c (The implementation
  was done for Radar 2442228 the header file was done for Radar 2470661).
  Radar bug #2477859.
- Changed dyld to use the new processor_facilities_used() call to determine if
  the thread has ever used floating-point and altvec registers and only save
  them if they have been used.  This effected the files images.c and
  mod_init_funcs.c  (The implementation was done for Radar 2442359 the header
  file was done for Radar 2470661). Radar bug #2477859.

- Changed bind_lazy_symbol_reference() in symbols.c to call
  link_library_module() when binding a lazy private extern since library
  module that defines private externs can also now define extern symbols.
  This makes sure that multiple definitions are caught.  This is needed so
  that if nmedit(1) is run on a dynamic library the right thing happens
  Part of Radar bug #2420307.

Changes for the 5.7 release (the cctools-329 release):
- Added the routine call_dependent_init_routines() to images.c and a call to it
  in call_image_init_routines() which causes dependent library initialization
  routines to be called.  Radar bug #2441683.
- Changed the uses of iinit and ninit fields of the struct dylib_module in
  in mod_init_funcs.c to iinit_iterm and ninit_nterm. Radar bug #2469527.
- Change the module_state to use bits to keep track of if a module init routine
  was called and if a module term routine was called.  This will allow 
  _dyld_call_module_initializers_for_dylib() (used for __initialize_Cplusplus)
  to call the module init routines and mark those that have been called so
  call_module_initializers() in mod_init_funcs.c not to call them again.
  Radar bug #2441683.
- Added the _dyld_mod_term_funcs() routine to mod_init_funcs.c added an entry
  for it in the dyld_funcs table in dyld_libfuncs.c so it can be looked up.
  It is looked up in crt1.o to register with atexit() to have module termination
  routines called.  Radar bug #2469527.
- Added the _dyld_call_module_initializers_for_dylib() routine to
  mod_init_funcs.c added an entry for it in the dyld_funcs table in
  dyld_libfuncs.c so it can be looked up.  It is looked up in dylib1.o for
  calls to __initialize_Cplusplus() to force module initialization routines
  in a specified dylib to be called.  Radar bug #2441683.
- Added a call to fork_mach_init() in start_debug_thread() in debug.c when
  start_from_core is TRUE.  Also added some code ifdef'ed CORE_DEBUG which
  sets the 6th word in the (__DATA,__dyld) section used to tell where the
  debug thread is from the task trying to start the debug thread. Radar bug
  #2155790.

Changes for the 5.7 release (the cctools-328 release):
- Changed the Makefile so that it would use -L/usr/local/lib/system moving
  forward and -L/Local/Developer/System when RC_RELEASE is Gonzo, Beaker or
  Bunsen.

Changes for the 5.7 release (the cctools-327 release):
- Changed the Makefile so that it would use -L/AppleInternal/Developer/System
  moving forward and -L/Local/Developer/System when RC_RELEASE is Gonzo, Beaker
  or Bunsen.
- Changed the ifdef's for the DEFAULT_FALLBACK_FRAMEWORK_PATH in dyld_init.h so
  that moving forward /MacOSX/Library/Frameworks is part of the default paths
  and /Local/Library/Frameworks is only used instead if __GONZO_BUNSEN_BEAKER__
  is defined for older DP4, DP3 & PR2 builds.

Changes for the 5.6 release (the cctools-324 release):
- Made the changes needed to make coalesced symbols work with using only
  prebound libraries.  The code in link_library_module() in symbols.c that
  disables prebinding when launching_with_prebound_libraries is TRUE was moved
  down after the check for the multiply defined symbols being coalesced symbols.
  Also a call to setup_prebound_coalesed_symbols() was added near the end of
  try_to_use_prebound_libraries() in images.c.
- Added a dummy _NSGetEnviron() routine in dyld_init.c because the Gonzo1I6
  versions of malloc() needs it.  If I don't define it then it uses the one
  from libc which needs __dyld_lookup_and_bind which can't be used in dyld.

Changes for the 5.6 release (the cctools-323 release):
- Changed the ifdef __SPACE__ for the DEFAULT_FALLBACK_FRAMEWORK_PATH in
  dyld_init.h as the directory changes have been scaled back and changed.
  In preparation of this "Half Plan" /Local/Library/Frameworks was changed to
  /MacOSX/Library/Frameworks and ifdef'ed __SPACE__.  In the second half of the
  plan (post-DP4) /System/Library/Frameworks will change to
  /MacOSX/System/Frameworks and this is ifdef'ed __SPACE2__.
- Changed back where dyld picks up its the System Framework's private 
  headers back to /System/Library/Frameworks/System.framework/PrivateHeaders
  from /MacOSX/System/Frameworks/System.framework/PrivateHeaders for the Space
  release.  This won't change till post-DP4.
- Changed _ppc_vec_save and _ppc_vec_restore in fp_save_restore.s to use the
  VRsave register to know which registers to save and restore now that gcc
  2.95 is the default and support VRsave.  Radar bug #2450639.

Changes for the 5.6 release (the cctools-322 release):
- Added ifdef's for __SPACE__ to the DEFAULT_FALLBACK_FRAMEWORK_PATH in
  dyld_init.h in preparation for the directory changes. /System/Library
  changing to /MacOSX/System.
- Added the zero-fill support for load_shared_file() with the #ifdef
  NEW_LOAD_SHARED_FILE and changed the casts in the call to load_shared_file()
  with this ifdef also.

Changes for the 5.6 release (the cctools-321 release):
- Changed the test of the return value of load_shared_file() from checking for
  not equal to 0 to testing for equal to -1 for the error case.

Changes for the 5.6 release (the cctools-320 release):
- Added an installhdrs target to the dyld Makefile to install images.h into
  System frameworks the local include directory as an egregious hack for
  sampler.  Note the upper Makefile was changed to call this target and also
  the include/Makefile installs "stuff/bool.h". (Radar bug #2376135).

Changes for the 5.6 release (the cctools-319 release):
- To support MH_SPLIT_SEGS formats where the r_address field of relocation
  entries is to be relitive to the first read-write segment a new field,
  segs_read_write_addr, was added to the image struct in images.h.  This then
  picked up in map_image() in images.c.  Then all the reloc routines were
  updated to use segs_read_write_addr in instead of seg1addr when calculating
  the value of r_slide to locate the item being relocated.

Changes for the 5.6 release (the cctools-316 release):
- Fixed a bug where the shared library init routines were not bound correctly
  when an attempt to use prebound libraries failed.  The problem was the
  FULLYBOUND_STATE of the modules and the library's init_bound was not reset in
  reset_module_states() in image.c (Radar bug #2428317).

Changes for the 5.5 release (the cctools-315 release):
- Fixed a bug where the floating point volatile and vector volatile registers
  were not being save when a shared library init or module init routine was
  called.  Radar bug #2424571.
- Fixed link_library_module() in symbols.c to correctly handle fully binding
  the private extern references for the shared library initialization routines.
  Radar bug #2423809.

Changes for the 5.5 release (the cctools-314 release):
- Added the DYLD_ABORT_MULTIPLE_INITS feature.  Radar bug #2423143.
- Fixed yet another bug relating to fully binding init routines.  This time
  after an init routine bound a module then a signal call was made to do a
  bind fully.  The code in link_library_module() in symbols.c incorrectly
  set the FULLY_LINKED module back to BEING_LINKED causing it to be relocated
  twice.  This showed up in Classic.  Radar bug #2413950 (again).
- Added the calls to unload_bundle_image() in image.c to send a
  DYLD_MODULE_REMOVED and a DYLD_IMAGE_REMOVED event.  Radar bug #2421760.
- The DYLD_MEM_PROTECT feature is broken in MacOS X Server because the hacks
  to override mig_get_reply_port() to not call mutex_try_lock() when
  vm_protect() is called did not take into account that the libc code on
  MacOS X Server did not have indr(l) properly run on it.  So the extra
  underbar '_' prefix needs to not be there for the MacOS X Server version in
  mig_support.c (so now the names with the underbar '_' prefix  is ifdef'ed
  __OPENSTEP__ where libc is properly indr(l)'ed).  Radar bug #2418378.

Changes for the 5.5 release (the cctools-313 release):
- Fixed a bug were fully binding the dependent modules for a shared library
  init routine did not fully bind modules that were already in the BEING_LINKED
  state.  To fix this a bit in the module state to indicate if the module is
  being fully bound was needed.  So two macros were added, GET_LINK_STATE and
  SET_LINK_STATE, to images.h.  And everywhere the link_state was set or read
  was changed to used these macros.  Then the macros GET_FULLYBOUND_STATE and
  SET_FULLYBOUND_STATE are used to get and set the bit to indicate fully
  bound.  The code to set this bit is in link_library_module() in symbols.c
  near the end of the routine.  And the code to test for this bit is in
  resolve_undefineds() in symbols.c. Radar bug #2419089.

Changes for the 5.5 release (the cctools-312 release):
- Added the routine setup_prebound_coalesed_symbols() in symbols.c to deal with
  prebinding and coalesced symbols.

Changes for the 5.5 release (the cctools-310 release):
- Updated the few places that did a binary search of the undefined symbols so
  that they use a linear search when the object image has MH_BINDATLOAD set.
  This is done because that the order of the undefined symbols is not sorted if
  -bind_at_load is used so the cases when -bind_at_load was used and the dynamic
  linker will resolved the undefined symbols in the same order as the static
  linker fixing a bug where something succesfully staticly linked but failed to
  dynamicly link.  Radar bug 2378121.

Changes for the 5.5 release (the cctools-309 release):
- Fixed a bug in the binding of image initialization routines.  The were not
  fully bound in that they did not cause modules the reference to be fully
  bound but just rather all references in the module that has the image
  initialization routine to be bound.  Radar bug #2413950.

Changes for the 5.5 release (the cctools-308 release):
- Added an #ifdef __OPENSTEP__ definition of getcwd() and a declaration of
  realpath() so things would compile on Openstep 4.2.

Changes for the 5.5 release (the cctools-307 release):
- Added support for coalesced symbols. Radar bug #2411273.
- Changed other places in dyld that undoes the prebinding to use the routines
  undo_prebinding_for_library_module(), make_image_writable() and
  restore_image_vm_protections() to simplify the code.  These were added in
  cctools-306 but due to risk for MacOS X PR2 not used everywhere until
  post-PR2.
- Really fixed Radar bug #2378121 where symbols other that the first one in the
  list may be used.  The new stratagy is that this must used with an executable
  that has MH_BINDATLOAD set (or when DYLD_BIND_AT_LAUNCH is set).  When the
  static link editor detects this case and prints a warning when it is needed.
  The change that was needed was to change lookup_symbol() when
  executable_bind_at_load was set, to keep searching for the first definition
  of a linked symbol before using a symbol not yet linked.  There are still
  cases because the undefined symbols are sorted this can still be different
  from the static linker even with MH_BINDATLOAD set.
- Picked up Chris Kane's changes for the DYLD_IMAGE_SUFFIX feature and the
  changes to eliminate an unneeded open()/close() pair or a stat()/fstat() pair
  in the cases a library has already been loaded.  Radar bug #2384450.

Changes for the 5.4 release (the cctools-306 release):
- Fixed a bug where a non-lazy pointer in a library module containing only
  private externs were not bound.  This showed up in C++ exception handling
  code in libcc_dynamic.a when copied in to a dynamic library.  The fix was
  in link_library_module() in symbols.c .  The new routine add_reference()
  was added to share the code to add references to undefined symbols.
  There also was a bug when bind_lazy_symbol_reference() is binding a symbol
  that is a private extern where the module that defined the private extern
  also has non-lazy references.  So in bind_lazy_symbol_reference() code was
  added to add the non-lazy references from the module before calling
  link_in_need_modules() for the case where the lazy symbol being bound is
  a private extern.  Radar bug #2391709.
- Fixed some bugs where library modules that containing private externs and
  external relocation entries which are prebound, do not have the prebinding
  backed out when the prebinding can't be used.  Two changes were made to 
  link_library_module().  The first is where the module has a reference to a
  private extern, if the module that defines the private extern is in the
  PREBOUND_UNLINKED state its prebinding is undone.  The second is where the
  library initialization routine is fully bound at the end of the routine,
  if the module that defines the library initialization routine is in the
  PREBOUND_UNLINKED state its prebinding is undone.
  Also there was a change was made to bind_lazy_symbol_reference() where
  it binds a symbol pointer for a private extern, if the module is in the
  PREBOUND_UNLINKED state its prebinding is undone.

  To support this the following routines were added to reloc.c:
  undo_prebinding_for_library_module(), make_image_writable() and
  restore_image_vm_protections().

Changes for the 5.4 release (the cctools-304 release):
- Ifdef out the change below in cctools-303.  This caused the fully binding
  case with signal handlers to be very slow.  This showed up in launching
  the Terminal app.

Changes for the 5.4 release (the cctools-303 release):
- Added code in link_library_module() in symbols.c to add defined symbols to
  the being linked list.  This is so that if a definition of a symbol is not
  being used from the first library that has a definition a later lazy binding
  will not use a different definition of the symbol. Radar bug #2378121.  Also
  see the comments at the end of lookup_symbol() for a case that is not yet
  handled.

Changes for the 5.4 release (the cctools-300 release):
- Added support for library initialization routines.

Changes for the 5.4 release (the cctools-299 release):
- Made two changes the _stub_binding_helper_interface for PowerPC.  The first
  was to remove the saving and restoring of r2 (toc) into the linkage area.
  This first change is needed to allow CFM vector libraries too work correctly
  as it was a bug in _stub_binding_helper_interface as the value of r2 (toc) is
  saved and set by the caller.  The second change was to increase the frame
  from 64 to 128 and change saving the registers that could contain parameters
  to be saved in the _stub_binding_helper_interface's saved register area
  rather than the caller's parameter save area.  This second change is needed
  as the caller many not have allocated a parameter save area large enough to
  save all possible parameter registers if it only calls parameterless
  functions.  Also did some minor changes, restored the parameters registers
  in low address to high for better cache behavior, and reschedule the getting
  of old link register value before parameter restores.  Radar bug #2358962.

Changes for the 5.4 release (the cctools-298 release):
- Added support for "@executable_path/" in library install names and picking
  up the kernel's passing the exec_path above envp's trailing 0.

Changes for the 5.4 release (the cctools-297 release):
- Fixed a bug in cctools-296 where the size of a symbol_block changed with the
  new remove_on_error field and that this was declared in assembly code which
  was not changed.

Changes for the 5.4 release (the cctools-296 release):
- Added the NSLINKMODULE_OPTION_RETURN_ON_ERROR option to NSLinkModule() and the
  new API NSLinkEditError() that returns the error information.
- Fixed a bug in NSAddLibrary() that did not load the dependent libraries.

Changes for the 5.4 release (the cctools-295 release):
- Fixed a bug in libdyld function _dyld_image_containing_address() which was
  addring the vmslide to the mach header address that it should not have done.

Changes for the 5.3 release (the cctools-294 release):
- Added the libdyld function _dyld_image_containing_address() to
  dyld_libfuncs.c.  Radar bug #2325380.

Changes for the 5.3 release (the cctools-293 release):
- Cut over to using the zone protect stuff in libc_dynamic.a now that it has
  suppose to appear in Beaker1K.  The file malloc.c is #ifndef'ed __MACH30__ .
  This was Tracker bug #48087 and Radar bug #2148087.
- Fixed the call to pthread_mutex_init() in malloc.c to have NULL as the second
  argument.  Also fixed a cast to call to malloc that needed a `*'.

Changes for the 5.3 release (the cctools-292 release):
- Ported malloc.c to used pthreads instead of cthreads.
- Added some braces to get rid of the warning message from the egcs compiler
  "warning: suggest explicit braces to avoid ambiguous `else'".  This was done
  to mod_init_funcs.c

Changes for the 5.3 release (the cctools-288 release):
- Fixed a bug where on PowerPC if the RESET_LAZY_REFERENCES NSUnLinkModule()
  option is used in a program that is not linked with crt1.0, bundle1.o or
  dylib1.o that has the ".long dyld_stub_binding_helper" fix.
- Changed call_module_initializers() in mod_init_funcs.c to use the iinit and
  ninit fields masked by 0xffff.  This is done to get a dyld out there before
  the high half of these feilds are used for module termination indexes and
  counts.  This will avoid programs crashing that have libraries that have
  module termination routines but are running with an old dyld.  With this dyld
  the library module termination routines won't get called but the program won't
  crash when the module initialization routines get called.
- Changed the printf() routine in errors.c to print to stderr not stdout and
  not call fflush() (Radar bug #2274737).

Changes for the 5.3 release (the cctools-287 release):
- Support for private images has been added.  Including support for the new API
  NSLookupSymbolInModule().
- The support for NSUnLinkModule for only MH_BUNDLE file types has been added.
- The support for the private NSMakePrivateModulePublic() call need for dlopen()
  has been added.

Changes for the 5.3 release (the cctools-286 release):
- Change the use of the i386 cpp macro to __i386__ and ppc to __ppc__
- Added the support for the module termination functions.  In this version they
  are only called for things loaded with NSLinkModule() when NSUnLinkModule()
  is called.  To test this the ifdef TESTING_MOD_TERM needs to be set.
  This effected the files images.c, mod_init_funcs.c, dyld_libfuncs.c,
  mod_init_funcs.h and images.h.

Changes for the 5.3 release (the cctools-285 release):
- Made a hack to errors.h to define the missing errno numbers for __MACH30__
  like it is done for __MWERKS__.
- Added #define'ing NeXT if not defined to mig_support.c
- Also picked up a change to the server_loop() in debug.c which did not
  correctly reset the thread suppend count of the thread_that_has_dyld_lock
  when it's suppend count was not 1.
- Picked up fixes in dyld_debug.defs and debug.c to the Mach 3.0 ported code
  made by David Peterson.

Changes for the 5.3 release, MacOS X bring up (the cctools-282 release):
- Changed host_self(), task_self(), thread_self() and port_deallocate() to
  mach_host_self(), mach_task_self(), mach_thread_self() and
  mach_port_deallocate() for MacOS X.  Also included "stuff/openstep_mach.h" for
  macros to allow it to still build on Openstep.  Also changed ifdef's __SLICK__
  to __OPENSTEP__.
- Changed the Makefile to allow for RC_OS=macos for MacOS X builds.
- Added an #ifdef __MACH30__ in _dyld_fork_child() and _dyld_fork_child_final()
  in dyld_libfuncs.c for resetting mach_task_self_ .
- Added an #ifdef __MACH30__ #import <mach/thread_switch.h> to lock.c
- Ifndef'ed out __MACH30__ for all of mig_support.c .
- Ifdef'ed the use of vm_region() in images.c for __MACH30__ differences and
  also changed port_t to mach_port_t.
- Changed port_t and thread_t to mach_port_t in debug.h and debug.c.  Added
  a typedef for msg_type_long_t for MacOS X bring up while the mig stuff is
  ifdef'ed out to debug.c.  Change PORT_NULL to MACH_PORT_NULL in debug.c.
  Ifndef'ed out __MACH30__ all of start_debug_thread() and server_loop() in
  debug.c for bring up.
- Added a typedef for msg_return_t to dyld_event_MsgError.h MacOS X bring up
  while the mig stuff is ifdef'ed out.
- Changed thread_t to mach_port_t in lock.h and lock.c.
- Ifdef'ed out the use of the profileServer stuff in dyld_init.c and images.c
  for __MACH30__ bring up.
- Ifdef'ed out most of the mig stuff in the .defs files for __MACH30__ for
  bring up.  And added some matching hacks in debug.c.

- Made a hack in the Makefile and if'ed mwcc the .s.o rule to use cc not
  $(CC).  As the MetroWerks compiler does not take .s files.
- Added #import <stuff/bool.h> to dyld_init.h so it would compile with the 
  MetroWerks compiler.
- Added the following:
    #ifdef __MWERKS__
    #define EBADEXEC	    85      /* Bad executable */
    #define EBADARCH        86      /* Bad CPU type in executable */
    #define ESHLIBVERS      87      /* Shared library version mismatch */
    #define EBADMACHO       88      /* Malformed Macho file */
    #endif
  to errors.h as the MetroWerks headers don't defined this.
- Removed the asm() in error.c to declare error_string into section_order.s to
  make it compile with the MetroWerks compiler.
- Removed the asm() in symbos.c to declare symbol_blocks into section_order.s to
  make it compile with the MetroWerks compiler.
- Changed the declaration of the address field dyld_funcs in dyld_libfuncs.c 
  from:
    unsigned long address;
  to:
    void (*address)(void);
  and changed the casts in the initialization to make it compile with the
  MetroWerks compiler.
- Changed the #undef task_self() to #undef task_self in dyld_libfuncs.c to make
  it compile with the MetroWerks compiler.
- Added an #import "stuff/bool.h" to lock.h to make it compile with the
  MetroWerks compiler.
- Added an ifneq:
    ifneq "mwcc" "$(notdir $(CC))"
      MIG_FLAGS = $(RC_CFLAGS) $(PGFLAGS)
    endif
  around the MIG_FLAGS as a hack to get it to compile with the MetroWerks
  compiler and not hang up on flags such as -relax_pointers -w off.
- Added #ifndef __MWERKS__ around the empty struct definitions in
  inbound_message_reply in debug.c
- Changed 4 (void *) casts to (char *) casts in malloc.c to make it compile
  with the MetroWerks compiler.
- Changed the Makefile to pass obscure ld flags via -Wl rather than directly
  with the compiler driver.

Changes for the 5.2 release (the cctools-274 release):
- Fixed a bug in validate_NSSymbol() in symbols.c where it was return NULL
  if the module is in the INITIALIZING state.  This can happen if a module
  initializer routine calls NSModuleForSymbol on a symbol in it's module.
  The fix is to allow modules in the INITIALIZING as well as the LINKED or
  FULLY_LINKED state to have info returned.  Radar bug #2238301.
- Changed load_executable_image() in images.c to use the first segment in the
  load commands as the seg1addr not the one with the lowest address. Radar bug
  #2237029.

Changes for the 5.2 release (the cctools-273 release):
- Added a print() function to errors.c that calls printf() and then fflush() on
  stdout.  This hopefully will fix the problem launcher is having when piping
  it's output.  Radar bug #2227265.  This bug was dropped from cctools-268.

Changes for the 5.2 release (the cctools-272 release):
- Changed the "bl L1" instructon to a "bcl 20,31 L1" in dyld_start.s for ppc.
  Radar bug #2231996.
- Fixed two bugs in load_library_image() in images.c when many dynamic libraries
  are used.  The problem is that when is_library_loaded() returns TRUE the file
  descriptor is not closed.  This leads to the second problem where the wrong
  errno is printed if the library can't be opened and then is searched for as
  the errno gets over written.  Radar bug #2230181.

Changes for the 5.2 release (the cctools-267 release):
- Added dyld_sample_debug for debugging shared pc sample buffer code.  Radar
  bug #2227592.
- Added a check in load_library_image() in images.c to make sure the file is a
  plain file and prints an error for that case.  This make it so the confusing
  can't map error message is not printed for the directory case.  Radar bug
  #2227477.
- Changed search_for_name_in_path() in images.c to skip paths with no
  characters in them.  Radar bug #2227589.

Changes for the 5.1 release (the cctools-264 release):
- Added a definition of getenv() that always returns NULL so the reference to
  _dyld_lookup_and_bind() is not pulled in by the libc_dynamic code.
  This is needed for isspace() in strtod needed by vsnprintf() for locale stuff.

Changes for the 5.1 release (the cctools-262 release):
- In Titan1P the profil(2) system call got fixed.  So the #ifdef SLICK code
  that was in shared_pcsample_buffer() in images.c which had the divide by 2
  was removed and now there is no #ifdef SLICK and the code that does not
  divide by 2 is used for both Rhapsody and #ifdef SLICK.  Radar bug #2215979.

Changes for the 5.1 release (the cctools-260 release):
- Added -c to all the install commands in the Makefile.

Changes for the 5.1 release (the cctools-259 release):
- Changed the Makefile to not use /usr/local/bin/install for Rhapsody but to
  just call strip and then install to make it work.

Changes for the 5.1 release (the cctools-258 release):
- Fixed shared_pcsample_buffer() in images.c to use the 4.4BSD profile header.
  Also delt with the bug in profil(2) in sizing the buffer.  See the detailed
  comments in the profileServer notes file.  Radar bug #2204555.

Changes for the 5.1 release (the cctools-257 release):
- Changed dyld -seg1addr from from 0x12000000 to 0x41100000 in the Makefile.
- Changed the Makefile to use /usr/local/bin/install for Rhapsody for dyld
  install to get at -sS option.

Changes for the 5.1 release (the cctools-253 release):
- Changed the default Framework fallback path to match the new directory
  layout for Preimer.

Changes for the 5.1 release (the cctools-250 release):
- Changed the ppc version _try_to_get_lock in machdep_lock.s to a version that
  lends itself to stepping over.  The old code could not be run in single
  step mode as it would alwasy loose the reservation.  The new code can be
  run to the next branch and not loose the reservation.  This is to allow some
  single step profiling tools.

Changes for the 5.1 release (the cctools-249 release):
- Changed the use of vsprintf() to vsnprintf() in errors.c in two places now
  that it exists in the 4.4bsd.  The code is in the else clause of an ifdef'ed
  __SLICK__ . This was filed as Tracker bug #48089.

Changes for the 5.1 release (the cctools-248 release):
- Fixed a bug where dyld could not slide itself on ppc.  The problem was caused
  by calling vm_flush_cache() which should not have been called.  The cache
  flushing does not have to be done when the code in compiled -dynamic.  See
  dyld_reloc.c for changes and comments.

Changes for the 5.1 release (the cctools-247 release):
- Added MKDIRS if code to the Makefile to build native on Rhapsody.
- Changed the Makefile to use gnutar instead of tar because it works on Rhapsody
  where tar does not.
- Changed the code ifdef __TEFLON__ to ifndef __SLICK__ (where __TEFLON__ will
  nolonger be defined for Rhapsody builds) so the default builds will be native
  Rhapsody builds.  The changes were dyld_init.c, errors.c, images.c and
  malloc.c

Changes for the 5.0 release (the cctools-235 release):
- Fixed the PPC_RELOC_BR24 to correctly check for overflow.  It now checks
  the top 7 (not 6) bits are the same. 

Changes for the 5.0 release (the cctools-226 release):
- Fixed a bug when the $HOME environment variable was not set.  The variable
  home was initialized to NULL and then later a strlen was done on it.  The
  fix was to in initialized it to "/".
- Fixed a bug in ppc_reloc where it was not correctly calculating the immediate
  of a HA16 reloc by checking the 0x8000 bit of the other half and and sign
  extending it and adding it to form the correct immediate.

Changes for the 5.0 release (the cctools-224 release):
- Defined NO_INDR_LIBC if __TEFLON__ is defined in malloc.c and errors.c so it
  will build with SDK2.

Changes for the 5.0 release (the cctools-222 release):
- Changed pickup_environment_variables() in dyld_init.c to not use atol() in
  getting the value for DYLD_PREBIND_DEBUG because it pulls in stuff in the
  TEFLON libc_dynamic.a that fails to link (locale stuff for "." which pulles
  in dyld_lookup_and_bind("__environ")).
- Added some ifdef's for NO_INDR_LIBC because the libraries are not indr'ed
  for the Teflon SDK2.
  In mach_error() in error.c for not using mach_error_string to avoid pulling
  in mach_error from -lc_dynamic and causing a multiply defined for
  "_mach_error".  In malloc.c changed _set_malloc_singlethreaded to
  set_malloc_singlethreaded without the underbar.
- Added -lcc_dynamic to the link line because for PowerPC the compiler appears
  to call libgcc functions unlike other architectures.
- Fixed a bug in stub_binding_helper.s for ppc which was incorrectly
  referencing _bind_lazy_symbol_reference in the assembly code without the
  leading underbar.

Changes for the 5.0 release (the cctools-221.4 and cctools-222 releases):
- Added including <mach-o/ppc/reloc.h> for ppc in images.c .
- Picked up changed entry_point.c to which changed struct ppc_thread_state_t to
  ppc_thead_state_t.

Changes for the 5.0 release (the cctools-221 release):
- Picked up the changes for the correct Rhapsody thread state changes into
  entry_point.c.

Changes for the 5.0 release (the cctools-219 release):
- Added searching fallback paths when dynamic libraries can't be found.  The
  Two paths are DYLD_FALLBACK_FRAMEWORK_PATH and DYLD_FALLBACK_LIBRARY_PATH.
  If these are not set they default to $(HOME)/Library/Frameworks:
  /LocalLibrary/Frameworks:/NextLibrary/Frameworks and $(HOME)/lib:
  /usr/local/lib:/lib:/usr/lib (bug #69135).

Changes for the 5.0 release (the cctools-218 release):
- Updated the PowerPC locking code with suggestions from colleagues.
- Updated ppc_cache_flush in cache_flush.s with suggestions from colleagues.

Changes for the 5.0 release (the cctools-217 release):
- Moved sparc_cache_flush.s to cache_flush.s and added _ppc_cache_flush in it
  that uses the "icbi" instruction cache block invalidate instruction.  Changed
  the relocation routines in ppc_reloc.c to use this.
- Wrote the machine dependent lock code for the PowerPC.
- Wrote __dyld_start for the PowerPC.
- Wrote _stub_binding_helper_interface for the PowerPC.
- Wrote and added ppc_reloc.c.
- Changed m98k ifdef to ppc in malloc.c.
- Added PowerPC support in for PPC_RELOC_PB_LA_PTR in images.c in 2 places.
- Added PowerPC support in get_entry_point() in entry_point.c.

Changes for the 4.2 release (the cctools-207 release):
- Fixed a bug in the DYLD_FRAMEWORK_PATH where if the framework has a suffix
  like _profile then DYLD_FRAMEWORK_PATH does not work.  The fix in in 
  get_framework_name() in images.c (bug #75900).

Changes for the 4.1 release (the cctools-203 release):
- Added DYLD_FRAMEWORK_PATH to search for frameworks.  If set and a dynamic
  library with a path of the form "Foo.framework/Versions/A/Foo" or
  "Foo.framework/Foo" (where the last component Foo is the framework name and
  the component A is any name) then "Foo.framework/Versions/A/Foo" or
  "Foo.framework/Foo" would be appended to each element in the
  DYLD_FRAMEWORK_PATH.  This is tried before DYLD_LIBRARY_PATH if it is set.
  This mostly effected images.c (bug #70403).

Changes for the 4.0 release (the cctools-200 release):
- The dyld debug interface can cause the program using it to crash if the target
  task has memory mapped from a file that has been removed over NFS.  The
  problem was the code in libdyld for the dyld debug interface was crashing when
  it used memory in response to a successful vm_read on this memory.  Two
  changes where made in libdyld.  First was to vm_read from the target task at
  the prefered address of dyld before going into the loop that scaned the
  address space.  Second in the loop that trys to start the debug thread only
  100 trys are made in the loop that is doing the thread_switch waiting for the
  debug thread to start.  If 100 trys are made it is assumed the debug thread
  can't be started and it returns failure.  This causes gdb to not crash and not
  hang and return continue without symbols from libraries.  With this a back
  trace is possible.  And one can still force library symbols to be loaded with
  the gdb add_module command (bug #65770).

Changes for the 4.0 release (the cctools-198 release):
- Added some code in the error case when a dynamic library was thin and for the
  other byte sex so it reported the library as wrong architecture instead of
  malformed (bug #65420).

Changes for the 4.0 release (the cctools-193 release):
- Fixed a bug in dyld's handling of library names for NSAddLibrary() where it
  did not save away the name of the library.  It simply used the pointer passed
  to it which caused future loads of librarys to get confused it the same space
  is used to load another library as dyld thinks it is already loaded (bug
  #63579).

Changes for the 4.0 release (the cctools-191 release):
- Fixed a bug where the call backs for registered for adding images was not
  being called immediately after NSAddLibrary() was finished.  This delayed the
  objc fixup until the next trip through dyld (bug #62882).

Changes for the 4.0 release (the cctools-190 release):
- Fixed a bug in the checking for symbols in the executable that are overriding
  library symbols.  The look in check_executable_for_overrides() was wrong in
  that dyst->iextdefsym was not added to the terminating value the index.  This
  caused some to try to use prebound libraries when they shouldn't.  This
  happened with the program gdb and the symbol catch_exception_raise (bug
  #62897).

Changes for the 4.0 release (the cctools-188 release):
- Fixed a bug in undoing the prebinding on RISC machines.  RISC machine
  instructions only hold part of a 32-bit expression that is being relocated.
  The other half of the expression is in a relocation entry.  When prebinding
  has to be undone the process has two steps.  First the prebound symbol value
  is substracted from the relocated expression.  Second the correct value of
  the symbol is added back to the relocated expression.  The bug in dyld is
  that the relocated expression is split between the instruction and a
  relocation entry and the part in the relocation entry is not updated.
  So when the second step is done it does not reconstruct relocated expression
  correctly.  The fix was to update the part of the relocated expresion stored
  in the relocation entry by first making the linkedit segment writeable and
  then storing the update half of the immediate (bug #62117).

Changes for the 4.0 release (the cctools-186 release):
- Fixed a bug in _dyld_bind_fully_image_containing_address() in dyld_libfuncs.c
  which did not deal with modules in the PREBOUND_UNLINKED state and call
  undo_external_relocation() before calling link_library_module() (bug #61399).

Changes for the 4.0 release (the cctools-181 release):
- Fixed a bug that cause dyld to crash when undoing the external relocation
  relocation entries in a prebound dynamic library.  It fails to make the
  segments which are read-only writeable before doing the relocation and gets
  a bus error when trying to write on read-only memory.  This had to be fixed
  in three places before undo_external_relocation() was called.  The three
  places were in resolve_undefineds() in symbols.c, _dyld_bind_objc_module()
  in dyld_libfuncs.c, and server_dyld_debug_bind_module() in debug.c
  (bug #59553).

Changes for the 4.0 release (the cctools-180 release):
- Change the sparc_reloc() routine to use the sparc flush instruction for
  sync'ing the icache (bug #59327).

Changes for the 4.0 release (the cctools-178 release):
- Fixed a bug where a if a non-prebound library gets loaded after the initial
  launch undo_prebinding_for_library() mistakenly gets called (bug #58805).
- To allow dyld to be linked with libc_dynamic.dylib (the libc_static code
  compiled -dynamic) two things were done.  The first was to add a definition
  of abort() to errors.c.  abort() is used by malloc() when it fails, so the
  abort() in errors.c just exits with DYLD_EXIT_FAILURE_BASE+DYLD_UNIX_RESOURCE.
  This eliminates undefined symbol __dyld_bind_fully_image_containing_address
  because signal.o gets pulled in with abort.o.  Second the DYLD_HANG_TIME
  feature was removed.  This eliminates undefined symbol __dyld_lookup_and_bind
  which used in getenv.o via timezone stuff and sleep (bug #58557 and #50228).

Changes for the 4.0 release (the cctools-177 release):
- Fixed a bug in external_relocation() and undo_external_relocaion() in
  sparc_reloc.c where reloc types SPARC_RELOC_HI22 and SPARC_RELOC_LO10
  had two statements reversed.  The addition of the value to the immediate was
  done before the extraction of the immeditate (bug #58729).
- Corrected the wording for compatibility version mismatch from "less than" to
  "greater than" (bug #58644).

Changes for the 4.0 release (the cctools-176 release):
- Changed _dyld_fork_child() and _dyld_fork_child_final() from calling
  mach_init() to calling task_self() and setting task_self_ which fixed the
  DYLD_MEM_PROTECT feature and allowed the system to boot with fork stubs that
  used _dyld_fork_child_final().
- Added _dyld_lookup_and_bind_objc() (bug #58442).
- Optimized undo_prebinding_for_library() by just setting the module_state to
  PREBOUND_UNLINKED instead of undoing all the relocation for all the modules
  (bug #58434).
- Fixed a bug where the time stamps of the libraries recorded in the executable
  did not match the libraries' time stamp prebinding was not correctly
  disabled.  The check was added in map_library_image() to match the check that
  was in is_library_loaded() (bug #58387).
- Fixed a bug in using just prebound libraries without prebound executables.
  A check needed to be made that the executable does not defined any symbols
  that the libraries defines and reference.  check_executable_for_overrides()
  in symbols was added and this is called in try_to_use_prebound_libraries()
  in images.c (bug #58357).
- Fixed a bug in external_relocation() and undo_external_relocaion() in
  sparc_reloc.c where reloc types SPARC_RELOC_WDISP22 and SPARC_RELOC_WDISP30
  were incorrectly assumed to have a pair (bug #58436).

Changes for the 4.0 release (the cctools-175 release):
- Added support for using just prebound libraries without prebound executables.

Changes for the 4.0 release (the cctools-173 release):
- Implemented the stuff needed for the dyld library functions: NSNameOfModule,
  NSLibraryNameForModule, NSNameOfSymbol, NSIsSymbolNameDefined,
  NSLookupAndBindSymbol, NSAddressOfSymbol, NSModuleForSymbol, NSAddLibrary.
  The first three are allowed to be called in a multiply defined handler.
- Removed the default link state from the image struct and the enum.  This is
  because for prebinding we are picking up which modules are bound from the 
  LC_PREBOUND_DYLIB commands.
- Added the support for using prebound images.  This touched a bunch of stuff in
  dyld_init.c and in images.c.

Changes for the 4.0 release (the cctools-171 release):
- Changed the check of the size of the shared pc sample buffer in
  shared_pcsample_buffer() to round to sizeof(unsigned short) because gprof
  complains when the number of samples in not a multiple that.
- Fixed a bug with shared_pcsample_buffer() which did not close the file
  descriptor for the shared pc sample buffer.  This caused getty to fail which
  was expecting to get file descriptor 0.

Changes for the 4.0 release (the cctools-170 release):
- Picked up the changed from the sparc project to dyld_reloc.c which added
  3 ifdef __DYNAMIC__ sequences so dyld could be compiled without -dynamic.
- Added the DYLD_INSERT_LIBRARIES feature which is set to a colon separated
  list of libraries that are inserted as the first libraries to be searched.
- Changed the support for fork() so that DYLD_MEM_PROTECT works by adding a
  _dyld_fork_child_final() call and changing _dyld_fork_child().  The change
  to _dyld_fork_child() was to save away the value of dyld_mem_prot and set
  it to FALSE.  Then in _dyld_fork_child_final() mach_init() is again call and
  dyld_mem_prot is restored.  This is done as the code in the fork stub messes
  with the ports and the vm_protect() call fails.
- Added in the real shared pcsample buffer interface called to dyld in
  dyld_init.c and images.c.

Changes for the 4.0 and Argon releases (the cctools-166.10 and cctools-170
releases):
- Changed THREAD_NULL to MACH_PORT_NULL so cctools will build in Argon.

Changes for the 4.0 release (the cctools-169.1 and cctools-170 releases):
- Fixed a bug in allocate_with_no_error_check() in allocate.c where it did not
  create the zone if it was NULL.

Changes for the 4.0 release (the cctools-169 release):
- Fixed a bug in map_library_image() that was saving the compatibility_version
  incorrectly from the user of the library not from the LC_ID_DYLIB of the
  library.

Changes for the 4.0 release (the cctools-168 release):
- Picked up sparc changes to stub_binding_helper.s, sparc_reloc.c, dyld_reloc.c
  and dyld_start.s .
- Added shared pcsample buffer stuff.  It is turned off right now with an ifdef
  SHARED_PCSAMPLE_BUFFERS_TESTING in dyld_init.c and images.c waiting for the
  server to be written.
- Added the functions _dyld_fork_prepare, _dyld_fork_parent and _dyld_fork_child
  to fix bug #55484 and to allow DYLD_MEM_PROTECT to work.
- Change the version numbers of dynamic library to the form X[.Y[.Z]] to match
  how next does versioning of it's projects.  This effected libtool(1), ld(1),
  otool(1), dyld, libstuff(version_number.c) and man pages for ld and libtool
  bug #55627).  In here the changes were in images.c .
- Fixed the i386 locking code in machdep_lock.s to use the xchgl instruction
  and also added the lock prefix in the old ifdef'ed out code (bug #55469).
- Added back a few const qualifiers now that -dynamic does not put these into
  the TEXT segment.
- Put symbol_blocks and error_string into their own section and ordered them
  at the end of the data section (see asm()'s in symbols.c and errors.c).  The
  file section_order.s was added to define the section load order and is loaded
  first.  This gets the data segment to one page plus the page(s) needed for the
  symbol blocks (which will not be needed for rocket launching).
- Tuned the data structure sizes so no malloc()'s are done by default.
- Changed allocation of symbol_list structs to come out of an array of 
  symbol_blocks so to dirty fewer pages.
- Added a pool to allocate module_state's out of for libraries.
- Changed what was "struct module" into module_state which is typedef'ed char
  to save allocated space for it (as a struct it was subject to a minimum
  alignment of a struct which was 2 or 4 bytes).
- Fixed a bug introduced in cctools-167 where the dylib_name was free()'ed and
  it shouldn't be.  Also added printing "dyld: " to DefaultMallocError() in
  my copy of malloc so I can tell it is the malloc in dyld that got hosed.
- Added _dyld_debug_module_name() to the dyld debug interface to get image's
  true names.
- Cleaned up a memory leak in server_dyld_debug_defining_module() in debug.c
  where the out of line data for name was not vm_deallocated().

Changes for the 4.0 PR1 release (the cctools-166.7 and cctools-168 releases):
- Changed the RELINKED state to FULLY_LINKED and made it first class state.
  This is so multiple calls that fully bind modules are fast after the first
  call (bug #55192).
- Changed is_library_loaded() in images.c to compare device and inode numbers
  if the name is not the same (bug #55085).

Changes for the 4.0 PR1 release (the cctools-166.4 and cctools-168 releases):
- Fixed a problem with bug fix #53397 in fully binding previously linked
  modules.  The problem was when a previously linked module was relinked it
  got relocated a second time.  To avoid this a new link state, RELINKED is
  used by link_library_module() and resolve_undefineds() in symbols.c.

Changes for the 4.0 release (the cctools-167 release):
- The name of the executable, argv[0] is saved in images.c and then used in
  printing error messages in error.c (bug #54144).
- Added a string table in images.c to save object file images names.  Also
  changed it so dylib names are used from the dylib id command when they
  are not changed do to DYLD_LIBRARY_PATH which avoids allocating space for
  them in the default case.
- Fixed a reported bug if DYLD_LIBRARY_PATH is set to nothing then something
  bad happens which I could not reproduce (I think a library gets loaded twice)
  (bug #54449).
- Added the DYLD_HANG_TIME feature for supporting sampling of launch times.

Changes for the 4.0 PR1 release (the cctools-166.3 and cctools-167 releases):
- Picked up the changes made to malloc for Lantern1X in dyld's copy.
- Fixed a bug in load_library_image() when DYLD_LIBRARY_PATH is set where the
  allocated name is not allocated with enough space when the search fails and
  the original name is used (bug #54542).
- Changed the way module initializers are called.  They are now started out
  delayed (that is not called).  Then when _dyld_make_delayed_module_initiali-
  zer_calls() is called (from crt1.o) the delayed initializers are called and
  future initializers are no longer delayed (bug #54334).
- Added the function _dyld_bind_fully_image_containing_address() to be used
  to fully bind functions that are installed as signal handlers.  This required
  the addtion of a bind_now parameter to the following routines:
  link_in_need_modules(), link_library_module() and resolve_undefineds().
  The link_library_module() bind_now does the same thing as link_object_module()
  in that it binds lazy symbols in when TRUE.  Also both of these functions
  now have an extra check when checking for multiply defined symbols to see
  if the symbol that is already defined is in the module being bound as a
  module may be lazy bound and later be fully bound (bug #53397).

Changes for the 4.0 PR1 release (the cctools-166.2 and cctools-167 releases):
- Fixed a bug in new_object_image() when more than NOBJECT_IMAGES (10) were
  loaded (bug #53456).

Changes for the 4.0 release (the cctools-165 release):
- Fixed the incorrect asumption that 0 was an invalid file descriptor and
  changed this to -1.  This was done in map_image() and the call to map_image()
  for mapping in object file images.
- Also added the DYLD_EBADEXEC_ONLY and DYLD_BIND_AT_LAUNCH environment
  variables.

Changes for the 4.0 release (the cctools-161 release):
- Fixed a bug in _dyld_moninit() which had the wrong increment expression for
  steping through the list of libraries.  This was:
	for(i = 0; i < q->nimages; q++){
  which should have been:
	for(i = 0; i < q->nimages; i++){
  This also appeared in two other places in dyld_libfuncs.c and in two places
  in debug.c.  In the _dyld_moninit() case this caused only the first dylib
  to get profiled.
- Also added some ifdef MALLOC_DEBUG in dyld_init.c and allocate.c so that
  libMallocDebug.a could be switched with malloc.o and used with malloc debug.

Changes for the 4.0 release (the cctools-160 release):
- Fixed the i386 machine dependent try_to_get_lock() assembly routine to use
  a bts (bit test and set instruction) because the use of the xchgl was just
  wrong.  Some how the code would work but it would cause the threads to spin
  in trying to get the lock.
- Fixed a problem with monaddition being called from dyld with the lock being
  set and then later trying to dynamicly bind things resulting in a dyld
  dead lock error.  This is not thread safe and could crash if objects are being
  unloaded while monaddition is being called.

Changes for the 4.0 release (the cctools-158 release):
- Added _dyld_fork_mach_init() which recalls mach_init() for use in the child
  side of fork so that the fork code can be in a dynamic library.  This is
  needed  as the value of task_self_ has changed and is an invalid port in the
  child and if used the in the dyld code it will fail.
- Changed it so that check_and_report_undefineds() gets called with the lock
  still taken and it releases the lock before calling the user's handler.  Then
  after the handler is called the lock is set again.  Made the same basic
  changes to the register functions and module initialization function calls.
- Added saving registers r20, r27 and r29 for the hppa in the
  _stub_binding_helper_interface which are assumed to be saved by a millicode
  call.  Also changed the hppa interface to add 64 bytes to the stack on entry
  because in the case of binding a millicode call in a leaf function it can't
  assume the caller will allocate space.  These two things were causing the
  hppa version of Lantern1P not to work.
- Fixed a few problems in load_library_image() with the code that deals with
  constructing library names with dyld_library_path.

Changes for the 4.0 release (the cctools-154 release):
- Fixed a bug that caused non-lazy pointers for N_INDR symbols not to get set.
  The problem was that the N_INDR symbol did not end up on the being_linked list
  and thus the non-lazy pointer for it was never set.
  The first part of the fix was in resolve_undefineds(), link_library_module()
  and link_object_module() to have the call to lookup_symbol() not to chase down
  the indirection loop but just find the N_INDR symbol.
  This was done by adding the special NO_INDR_LOOP argument as the indr_loop
  argument to lookup_symbol().
  The second part of the fix was in relocate_symbol_pointers_in_object_image()
  and relocate_symbol_pointers_in_library_image() if the symbol on the
  being_linked list was an N_INDR symbol a lookup_symbol() is called to get
  the correct value of the symbol before calling relocate_symbol_pointers().

- Added support for stripping defined externals that appear as indirect symbol
  table entries in non-lazy pointer sections.  Strip uses the values
  INDIRECT_SYMBOL_LOCAL and INDIRECT_SYMBOL_ABS to represent the symbols that
  are defined that were stripped. relocate_symbol_pointers_for_defined_externs()
  uses these values to know wether or not to adjust the value of the non-lazy
  pointer.
- Fixed uses of defined absolute symbols that was adding the vmaddr_slide to
  them.  This occured in a number of places.  Now testing is done if the type
  is not N_ABS then the vmaddr_slide is added.

Changes for the 4.0 release (the cctools-150 release):
- Added code in bind_lazy_symbol_reference() to handle private extern symbols
  being lazy bound.
- Changed with the the event message that this image was added is set to after
  the local relocation is done in map_library_image().

Changes for the 4.0 release (the cctools-149 release):
- Fixed the problem with the dynamic linker relocating itself when compiled with
  -dyanmic as introduced in cctools-148.  Three changes to _dyld_reloc() in
  dyld_reloc.c were made.  First was the reference to _mh_dylinker_header,
  second was the reference to SEG_LINKEDIT and third was adding the missing call
  to relocate_symbol_pointers_for_defined_externs() (bug #50582).
- Changed the way cache_sync_on_reloc gets set.  It is now based on
  S_ATTR_SOME_INSTRUCTIONS instead of S_ATTR_PURE_INSTRUCTIONS which is set by
  the assembler for all sections that it assembles instructions into.
- Changed the way set uid (and set gid) programs and DYLD_LIBRARY_PATH are
  handled.  If the programs is setuid or setgid then dyld_library_path is not
  set and the environment variable DYLD_LIBRARY_PATH is written on so that
  programs that are exec'ed do not have it set.
- Added support for executables built that should be bound at launch time.  If
  the executable has the MH_BINDATLOAD flag in the mach header (built with the
  -bind_at_load to ld(1)) then dyld_init() sets executable_bind_at_load and when
  a module is to be bound all undefined references (lazy and non-lazy) are added
  to the list of needed symbols.  This is also supported in the mach header of
  bundle files.
- Finished the multiply defined error handler so that a new symbol can be
  specified to be used.  This changed effected multiply_defined_error() in
  error.c to mark the symbol as discarded (N_DESC_DESCARDED in the n_desc
  field of the nlist struct).  To do this the linkedit segment is made writable
  to do this.  This mark is then looked for in lookup_symbol() in symbols.c .
  Also added was the routine change_symbol_pointers_in_images() in symbols.c
  which is called from multiply_defined_error() to reset the values of symbol
  pointers if the symbol changes.
- Added the arguments new_image and prev_image to multiply_defined_error()
  which are a pointers to the images for the new and previous definitions of
  the symbols.
- Changed the first call to vm_protect() (for libraries not objects) in
  relocate_modules_being_linked() in reloc.c to use (VM_PROT_WRITE |
  VM_PROT_READ | VM_PROT_EXECUTE) instead of maxprot.
- Added a check in load_executable_image() in images.c for segments that have
  external relocation (S_ATTR_EXT_RELOC) to make sure the maxprot has
  VM_PROT_WRITE and VM_PROT_READ.
- Removed the unused first argument symbol_name from relocate_symbol_pointers()
  in symbols.c.

Changes for the 4.0 release (the cctools-148 release):
- Changed how dyld gets built.  Now it gets built with -dynamic.  Had to add
  a fake dyld_stub_binding_helper to dyld_init.s which traps so it will link.
  Added compiling with -O and not building dyld.o.  Removed most of the hack in
  the Makefile because this will only be built with 4.0 tools now.
- Now installs dyld with strip -S.

Changes for the 4.0 release (the cctools-147 release):
- Added support for profiling dyld loaded code.
- Added _dyld_get_image_name().

Changes for the 4.0 release (the cctools-145 release):
- Fixed references to private externs symbols in libraries so that the library
  module that defines them is forced to be linked in.  This is need so that
  module init functions, register functions for linking and debug events get
  triggered for these modules.  The code is in symbols.c at the end of
  link_library_module().  This now closes the issue about putting the private
  extern symbols in a dylibs table of contents.  These modules may never be
  unlinked or replaced (just a the library can't be unloaded).
- Fixed a bug in the m68k _stub_binding_helper_interface where the calling
  convention has  a1 as a pointer to an area to return structures and needs to
  be saved.  Since this wasn't accounted for we are forced to save it and
  shuffle the arguments in the assembly interface.
- Fixed three bugs in the hppa _stub_binding_helper_interface where registers
  that should have been saved weren't.  The first was %r28 which is a pointer
  to an area to return structures.  The second was %r31 which is the millicode
  return address register.  And third were the argument registers 2 and 3 which
  should also have been saved as they are treated as caller save registers.
- Added dyld allocated memory protection via the environment variable
  DYLD_MEM_PROTECT.  This involved picking up malloc.c and adding the
  zoneprotect stuff to it.  This could have problems when used with the debugger
  interface and should not be used.
- Changed the time outs for the debug mach messages from 30 seconds to 4
  miniutes.  The debugger was timing out in reading large dylibs.  It shouldn't
  process the messages when it gets them but rather just create a list of things
  to do and then do them.
- Fixed a bug in the locking of the dyld data structures.  What was happening
  is that lock and thread_that_has_lock could be inconsistant as the lock can
  get taken by a thread and it switch out of before thread_that_has_lock is
  set to thread_self().  Then an other thread can find the lock set and in
  checking for a dead lock will test thread_that_has_lock against thread_self()
  and think it is a dead lock.  The fix was somewhat extensive.  Lock was
  changed to global_lock and used to protect dyld_lock and
  thread_that_has_dyld_lock.  Now global_lock is lock to inspect or set either
  of dyld_lock or thread_that_has_dyld_lock.  Then to make the debugger it
  depends order of setting and clearing of dyld_lock and
  thread_that_has_dyld_lock are such that if dyld_lock is true
  thread_that_has_dyld_lock will be vaild or THREAD_NULL.  The later case can
  only happen when a tread is unlocking.  So in set_lock and release_lock if
  it is the debug thread nothing is done because if there was a thread that had
  the lock it was resumed or it's trying to release the lock and it it fine.

Changes for the 4.0 release (the cctools-143 release):
- Change it so that registered functions get called when the dyld lock is not
  out.  This added a new link state.
- Changed the order dependent libraries of dymanic libraries get loaded.  To
  get all of the executables libraries loaded before libraries dependent
  libraries.  The change was in map_library_image() the call to
  load_images_libraries() was removed.  Then a new flag,
  dependent_libraries_loaded, was added to the library_image structure.  Then
  the routine load_dependent_libraries() was added to call
  load_images_libraries() for library images where dependent_libraries_loaded
  was FALSE.  load_dependent_libraries() is called from link_in_need_modules().
- Added dealing with N_INDR symbols in the dynamic linker and doing checking of
  N_INDR symbol loop checking.  This is in lookup_symbol() in symbols.c.
- Fixed a bug that did not have the correct address of the dynamic link editor's
  mach header for DYLD_IMAGE_ADDED events when the dynamic linker was not moved
  from it's staticly linked address.  The fix was to initialize
  dyld_image_header to the value of &_mh_dylinker_header in dyld_reloc.c .

Changes for the 4.0 release (the cctools-141 release):
- Fixed a problem with module bound events for the exectable not being reported.
  The was a problem in that the link_state was not set to LINKED by
  call_module_initializers().  This was also a problem for objects loaded that
  had no section marked with S_MOD_INIT_FUNC_POINTERS.
- Added support for runtime loading.  Only loading of MH_BUNDLE files is
  currently supported (no unloading, replacing).  This is the minimum support
  to get programs using bundles up.  This includes the routines to register
  functions for loading and binding for the Objective-C runtime.

Changes for the 4.0 release (the cctools-138 release):
- Changed relocate_symbol_pointers_for_private_externs() to
  relocate_symbol_pointers_for_defined_externs() which adds the vmaddr_slide
  to all non-lazy pointers for symbols defined in the library (private or not).
  This can happen with ld -r modules where a non-lazy pointer can end up with
  a defined symbol.
- Added the calling of module initializaton routines.
- Changed the locking for _dyld_lookup_and_bind() in dyld_libfuncs.c and moved
  it into bind_symbol_by_name() in symbols.c because it can cause the user's
  undefined symbol handler to be called and the lock must be released before it
  is called.

Changes for the 4.0 release (the cctools-136 release):
- Changed dyld_start for the i386 to push a zero as a end of frame marker for
  the debugger and reset %ebp to zero because crt1.o pushes it's value as the
  end frame marker.

Changes for the 4.0 release (the cctools-135 release):
- Finished the dyld debug interface stuff.

Changes for the 4.0 release (the cctools-134 release):
- Started adding the dyld debug interface stuff.  This stuff is incomplete at
  this release but will compile cleanly.
- Picked up the sparc fix to entry_point.c which was using the wrong struct
  and field to get the entry point.
- Fixed a problem with the machine dependent locks on the m68k and i386 where
  the address of the lock was passed to the assembly routines and there was a
  missing indirection.

Changes for the 4.0 release (the cctools-133 release):
- Stub'ed out all the machine dependent stuff for sparc so at least it can
  build without problems.
- Started in on the debug interface.
- Added the setting and calling of the user's error handlers.
- Added the lock and the locking for the dyld data structures.
- Fixed a bug in dyld_start.s for the hppa where the it was calling _dyld_init
  not __dyld_init as it should have been.
- Fixed a bug in dyld_start.s for the m68k where the argument for __dyld_reloc
  had a sp@+ instead of sp@- for the move of the argument on to the stack.

Changes for the 4.0 release (the cctools-132 release):
- Got hppa support done (relocation, dyld_start, entry_point).

Changes for the 3.3 release (the cctools-127 release):
- Got the kernel interface support debugged (under the i386).  A few fixes, in
  __dyld_start for the i386 the mh parameter was put at 4 off the esp which was
  changed to zero, also in __dyld_start for both the i386 and m68k the mh
  argument was not removed before calling the entry point, in generic_reloc.c
  in local_relocation reloc[i].field was being used were field was broken out
  depending on if the entry was scattered so it was changed to use the broken
  out fields and in dyld_reloc() SEG_LINKEDIT needed vmaddr_slide added to it
  to allow it to run before the code was relocated.

Changes for the 3.3 release (the cctools-122 release):
- Fixed a bug in the relocate_symbol_pointers_in_library_image() that did not
  calculate the symbol_index right (the two values were reversed) this bug was
  already fixed in relocate_symbol_pointers_in_object_image().
- Fixed a bug in relocate_symbol_pointers() that did not add the 
  image->vmaddr_slide value to the address to be set with the symbol value.

Changes for the 3.3 release (the cctools-120 release):
- Figured out what is needed in the way of compiler changes need at this point.
  They are:

* Change the i386 symbol stub code to fix bugs in the code (yes I gave you code
  that does not work, I've tested this new stuff).
  For non-pic stubs, from this:
		.symbol_stub
	Lfoo$stub:
		.indirect_symbol _foo
		ljmp     L_foo$lazy_ptr
	Lfoo$stub_binder:
		pushl   $L_foo$lazy_ptr
		jmp     stub_binding_helper
  to this:
		.symbol_stub
	Lfoo$stub:
		.indirect_symbol _foo
		jmp     *L_foo$lazy_ptr
	Lfoo$stub_binder:
		pushl   $L_foo$lazy_ptr
		jmp     dyld_stub_binding_helper

  For pic code, from this:
	.picsymbol_stub
	<< I never wrote this case down >>

  to this:
		.picsymbol_stub
	Lfoo$stub:
		.indirect_symbol _foo
		call	L1foo$stub
	L1foo$stub:
		popl	%eax
		movl	L_foo$lazy_ptr-L1foo$stub(%eax),%ebx
		jmp	%ebx
	Lfoo$stub_binder:
		lea	L_foo$lazy_ptr-L1foo$stub(%eax),%eax
		pushl	%eax
		jmp     dyld_stub_binding_helper

* Change the m68k symbol stub code to fix bugs in the code.
  For non-pic stubs, from this:
	.symbol_stub
	Lfoo$stub:
		.indirect_symbol _foo
		jmp	@(L_foo$lazy_ptr)
	Lfoo$stub_binder:
		movel	#L_foo$lazy_ptr,sp@-
		bra	stub_binding_helper
		.lazy_symbol_pointer

  to this:
	.symbol_stub
	Lfoo$stub:
		.indirect_symbol _foo
		movel	L_foo$lazy_ptr,a0
		jmp	a0@
	Lfoo$stub_binder:
		movel	#L_foo$lazy_ptr,sp@-
		bra	stub_binding_helper
		.lazy_symbol_pointer

  For pic code, from this:
	.picsymbol_stub
	Lfoo$stub:
		.indirect_symbol _foo
		jmp	pc@(L_foo$lazy_ptr-.)
	Lfoo$stub_binder:
		movel	pc@(L_foo$lazy_ptr-.),sp@-
		bra	stub_binding_helper
  to this:
	.picsymbol_stub
	Lfoo$stub:
		.indirect_symbol _foo
		movel	pc@(L_foo$lazy_ptr-.),a0
		jmp	a0@
	Lfoo$stub_binder:
		pea	pc@(L_foo$lazy_ptr-.)
		bra	dyld_stub_binding_helper

* Change the name of the symbol stub_binding_helper to dyld_stub_binding_helper.
  I want all names associated with the dynamic linker to start with "dyld".

* Change the compiler driver to pass "-NEXTSTEP-deployment-target XXX" to as(1)
  and ld(1).  I see no reason to pass it to lipo(1) which is the other tool I
  own which cc(1) runs.

* Change the compiler driver when "-NEXTSTEP-deployment-target 3.3" is seen to
  use -lcrt1.o instead of -lcrt0.o .  I would suggest we leave the default as
  3.2 until we have this all working (which will be still quite some time).

* Also if the -object or -preload ld(1) options are seen always link with
  -lcrt0.o (reguardless of the -NEXTSTEP-deployment-target flag).
  
* Add the new ld flags to the compiler driver to pass them through to ld(1) if
  specified:
	-dylinker
	-dylinker_install_name XXX
	-output_for_dyld
	-keep_private_externs
 
- Agreed on a kernel interface for the 3.3 kernel.   This was the email I sent
  to David Bohman after a discussion on this:

The kernel when it is executing an a.out with an LC_LOAD_DYLINKER command will
do the following:

* Map the segments Mach-O file specified by the LC_LOAD_DYLINKER into memory.
  If the vmaddress of the segments are not available it will "slide" it to the
  any available address.  The segment of this Mach-O will be contigious so the
  kernel can determine the size of the needed memory by adding up the vmsize's
  of the LC_SEGMENT commands.

* Then the kernel will use the entry point in the LC_LOAD_DYLINKER (plus any
  slide amount) to start the task instead of the entry point in the a.out.

* One additional argument will be passed to the entry point in the
  LC_LOAD_DYLINKER in addition to the normal argc, argv, envp.  This argument is
  the value of the address where the a.out's file offset 0 appears in memory.
  That is the vmaddr of the LC_SEGMENT command of the a.out who's fileoff is 0
  (which is the address of the a.out's mach_header in memory).  If there is no
  such segment in an a.out with an LC_LOAD_DYLINKER the exec(2) should fail with
  and EBADEXEC or some such thing.  This extra argument will be first on stack
  based architectures like the m68k and i386 such that if it is removed from the
  stack the interface is the same as it is to the a.out's entry point.  For
  example the m68k interface would be:
	/*
	 * Runtime startup for NeXT m68k interface to the dynamic linker. 
	 * This is the same as crt0.s with the addition of the address of
	 * the a.out's mach header passed as the an extra first argument.
	 *
	 * Kernel sets up stack frame to look like:
	 *
	 *	| STRING AREA |
	 *	+-------------+
	 *	|      0      |
	 *	+-------------+
	 *	|    env[n]   |
	 *	+-------------+
	 *	       :
	 *	       :
	 *	+-------------+
	 *	|    env[0]   |
	 *	+-------------+
	 *	|      0      |
	 *	+-------------+
	 *	| arg[argc-1] |
	 *	+-------------+
	 *	       :
	 *	       :
	 *	+-------------+
	 *	|    arg[0]   |
	 *	+-------------+
	 *	|     argc    |
	 *	+-------------+
	 * sp->	|      mh     | Address of where the a.out's file offset 0 is
	 *	+-------------+ in memory.
	 *
	 *	Where arg[i] and env[i] point into the STRING AREA
	 */
  For the RISC architectures we will needed to work out the interface as to
  where this extra argument will be.

* You also want to think about what you want the dynamic linker is to do in the
  case of an EBADEXEC like error (like a dynamic shared file is not found).  I
  could send a mach message on a specific port or something to tell the parent
  that even though the exec(2) did not fail the task did not run successfully.

* We also wanted to allow the user to control where and how big his stack is.
  The kernel would check the stack pointer of the LC_UNIXTHREAD and if it was
  non-zero would use that as the stack pointer.  The a.out file must also have
  an LC_SEGMENT that allocates the stack's memory which contains the stack
  pointer's value.  This would be implemented in the static link editor, ld(1),
  by specifying "-stack_size hex_number" and possibly additionally
  "-stack_pointer hex_number".  The static link editor will create a zerofill
  segment named __UNIXSTACK of the indicated size and set the stack pointer to
  the top or bottom depending on the way the architecture grows it's stack.

* Lastly we wanted to change the project ownership of <mach-o/loader.h> and
  <mach-o/nlist.h>.  The first is installed by mk project and the later is
  installed by the libc project.  The ownership should be the cctools project.
  Here's the current copy of <mach-o/loader.h> as in the cctools project:

  Just tell me when you want me to change the cctools project to start
  installing <mach-o/loader.h> and the mk project can just stop installing it.
  Also who do I need to talk to with reguard to the libc project and the
  ownership of <mach-o/nlist.h>?

Changes for the 3.3 release (the cctools-115 release):
- Started writing the dynamic link editor.
